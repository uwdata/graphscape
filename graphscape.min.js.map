{"version":3,"file":"graphscape.min.js","sources":["node_modules/vega-util/build/vega-util.module.js","node_modules/vega-expression/build/vega-expression.module.js","src/constants.js","src/util.js","src/editOp/editOpSet.js","src/transition/neighbor.js","src/transition/trans.js","lib/TSP.js","src/sequence/PatternOptimizer.js","src/sequence/TieBreaker.js","src/sequence/sequence.js","src/transition/apply.js","src/path/enumerate.js","src/path/evaluateRules.js","src/path/evaluate.js","src/path/index.js","src/index.js"],"sourcesContent":["function accessor (fn, fields, name) {\n  fn.fields = fields || [];\n  fn.fname = name;\n  return fn;\n}\nfunction accessorName(fn) {\n  return fn == null ? null : fn.fname;\n}\nfunction accessorFields(fn) {\n  return fn == null ? null : fn.fields;\n}\n\nfunction getter (path) {\n  return path.length === 1 ? get1(path[0]) : getN(path);\n}\n\nconst get1 = field => function (obj) {\n  return obj[field];\n};\n\nconst getN = path => {\n  const len = path.length;\n  return function (obj) {\n    for (let i = 0; i < len; ++i) {\n      obj = obj[path[i]];\n    }\n\n    return obj;\n  };\n};\n\nfunction error (message) {\n  throw Error(message);\n}\n\nfunction splitAccessPath (p) {\n  const path = [],\n        n = p.length;\n  let q = null,\n      b = 0,\n      s = '',\n      i,\n      j,\n      c;\n  p = p + '';\n\n  function push() {\n    path.push(s + p.substring(i, j));\n    s = '';\n    i = j + 1;\n  }\n\n  for (i = j = 0; j < n; ++j) {\n    c = p[j];\n\n    if (c === '\\\\') {\n      s += p.substring(i, j);\n      s += p.substring(++j, ++j);\n      i = j;\n    } else if (c === q) {\n      push();\n      q = null;\n      b = -1;\n    } else if (q) {\n      continue;\n    } else if (i === b && c === '\"') {\n      i = j + 1;\n      q = c;\n    } else if (i === b && c === \"'\") {\n      i = j + 1;\n      q = c;\n    } else if (c === '.' && !b) {\n      if (j > i) {\n        push();\n      } else {\n        i = j + 1;\n      }\n    } else if (c === '[') {\n      if (j > i) push();\n      b = i = j + 1;\n    } else if (c === ']') {\n      if (!b) error('Access path missing open bracket: ' + p);\n      if (b > 0) push();\n      b = 0;\n      i = j + 1;\n    }\n  }\n\n  if (b) error('Access path missing closing bracket: ' + p);\n  if (q) error('Access path missing closing quote: ' + p);\n\n  if (j > i) {\n    j++;\n    push();\n  }\n\n  return path;\n}\n\nfunction field (field, name, opt) {\n  const path = splitAccessPath(field);\n  field = path.length === 1 ? path[0] : field;\n  return accessor((opt && opt.get || getter)(path), [field], name || field);\n}\n\nconst id = field('id');\nconst identity = accessor(_ => _, [], 'identity');\nconst zero = accessor(() => 0, [], 'zero');\nconst one = accessor(() => 1, [], 'one');\nconst truthy = accessor(() => true, [], 'true');\nconst falsy = accessor(() => false, [], 'false');\n\nfunction log(method, level, input) {\n  const args = [level].concat([].slice.call(input));\n  console[method].apply(console, args); // eslint-disable-line no-console\n}\n\nconst None = 0;\nconst Error$1 = 1;\nconst Warn = 2;\nconst Info = 3;\nconst Debug = 4;\nfunction logger (_, method) {\n  let level = _ || None;\n  return {\n    level(_) {\n      if (arguments.length) {\n        level = +_;\n        return this;\n      } else {\n        return level;\n      }\n    },\n\n    error() {\n      if (level >= Error$1) log(method || 'error', 'ERROR', arguments);\n      return this;\n    },\n\n    warn() {\n      if (level >= Warn) log(method || 'warn', 'WARN', arguments);\n      return this;\n    },\n\n    info() {\n      if (level >= Info) log(method || 'log', 'INFO', arguments);\n      return this;\n    },\n\n    debug() {\n      if (level >= Debug) log(method || 'log', 'DEBUG', arguments);\n      return this;\n    }\n\n  };\n}\n\nvar isArray = Array.isArray;\n\nfunction isObject (_) {\n  return _ === Object(_);\n}\n\nconst isLegalKey = key => key !== '__proto__';\n\nfunction mergeConfig(...configs) {\n  return configs.reduce((out, source) => {\n    for (const key in source) {\n      if (key === 'signals') {\n        // for signals, we merge the signals arrays\n        // source signals take precedence over\n        // existing signals with the same name\n        out.signals = mergeNamed(out.signals, source.signals);\n      } else {\n        // otherwise, merge objects subject to recursion constraints\n        // for legend block, recurse for the layout entry only\n        // for style block, recurse for all properties\n        // otherwise, no recursion: objects overwrite, no merging\n        const r = key === 'legend' ? {\n          layout: 1\n        } : key === 'style' ? true : null;\n        writeConfig(out, key, source[key], r);\n      }\n    }\n\n    return out;\n  }, {});\n}\nfunction writeConfig(output, key, value, recurse) {\n  if (!isLegalKey(key)) return;\n  let k, o;\n\n  if (isObject(value) && !isArray(value)) {\n    o = isObject(output[key]) ? output[key] : output[key] = {};\n\n    for (k in value) {\n      if (recurse && (recurse === true || recurse[k])) {\n        writeConfig(o, k, value[k]);\n      } else if (isLegalKey(k)) {\n        o[k] = value[k];\n      }\n    }\n  } else {\n    output[key] = value;\n  }\n}\n\nfunction mergeNamed(a, b) {\n  if (a == null) return b;\n  const map = {},\n        out = [];\n\n  function add(_) {\n    if (!map[_.name]) {\n      map[_.name] = 1;\n      out.push(_);\n    }\n  }\n\n  b.forEach(add);\n  a.forEach(add);\n  return out;\n}\n\nfunction peek (array) {\n  return array[array.length - 1];\n}\n\nfunction toNumber (_) {\n  return _ == null || _ === '' ? null : +_;\n}\n\nconst exp = sign => x => sign * Math.exp(x);\n\nconst log$1 = sign => x => Math.log(sign * x);\n\nconst symlog = c => x => Math.sign(x) * Math.log1p(Math.abs(x / c));\n\nconst symexp = c => x => Math.sign(x) * Math.expm1(Math.abs(x)) * c;\n\nconst pow = exponent => x => x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n\nfunction pan(domain, delta, lift, ground) {\n  const d0 = lift(domain[0]),\n        d1 = lift(peek(domain)),\n        dd = (d1 - d0) * delta;\n  return [ground(d0 - dd), ground(d1 - dd)];\n}\n\nfunction panLinear(domain, delta) {\n  return pan(domain, delta, toNumber, identity);\n}\nfunction panLog(domain, delta) {\n  var sign = Math.sign(domain[0]);\n  return pan(domain, delta, log$1(sign), exp(sign));\n}\nfunction panPow(domain, delta, exponent) {\n  return pan(domain, delta, pow(exponent), pow(1 / exponent));\n}\nfunction panSymlog(domain, delta, constant) {\n  return pan(domain, delta, symlog(constant), symexp(constant));\n}\n\nfunction zoom(domain, anchor, scale, lift, ground) {\n  const d0 = lift(domain[0]),\n        d1 = lift(peek(domain)),\n        da = anchor != null ? lift(anchor) : (d0 + d1) / 2;\n  return [ground(da + (d0 - da) * scale), ground(da + (d1 - da) * scale)];\n}\n\nfunction zoomLinear(domain, anchor, scale) {\n  return zoom(domain, anchor, scale, toNumber, identity);\n}\nfunction zoomLog(domain, anchor, scale) {\n  const sign = Math.sign(domain[0]);\n  return zoom(domain, anchor, scale, log$1(sign), exp(sign));\n}\nfunction zoomPow(domain, anchor, scale, exponent) {\n  return zoom(domain, anchor, scale, pow(exponent), pow(1 / exponent));\n}\nfunction zoomSymlog(domain, anchor, scale, constant) {\n  return zoom(domain, anchor, scale, symlog(constant), symexp(constant));\n}\n\nfunction quarter(date) {\n  return 1 + ~~(new Date(date).getMonth() / 3);\n}\nfunction utcquarter(date) {\n  return 1 + ~~(new Date(date).getUTCMonth() / 3);\n}\n\nfunction array (_) {\n  return _ != null ? isArray(_) ? _ : [_] : [];\n}\n\n/**\n * Span-preserving range clamp. If the span of the input range is less\n * than (max - min) and an endpoint exceeds either the min or max value,\n * the range is translated such that the span is preserved and one\n * endpoint touches the boundary of the min/max range.\n * If the span exceeds (max - min), the range [min, max] is returned.\n */\nfunction clampRange (range, min, max) {\n  let lo = range[0],\n      hi = range[1],\n      span;\n\n  if (hi < lo) {\n    span = hi;\n    hi = lo;\n    lo = span;\n  }\n\n  span = hi - lo;\n  return span >= max - min ? [min, max] : [lo = Math.min(Math.max(lo, min), max - span), lo + span];\n}\n\nfunction isFunction (_) {\n  return typeof _ === 'function';\n}\n\nconst DESCENDING = 'descending';\nfunction compare (fields, orders, opt) {\n  opt = opt || {};\n  orders = array(orders) || [];\n  const ord = [],\n        get = [],\n        fmap = {},\n        gen = opt.comparator || comparator;\n  array(fields).forEach((f, i) => {\n    if (f == null) return;\n    ord.push(orders[i] === DESCENDING ? -1 : 1);\n    get.push(f = isFunction(f) ? f : field(f, null, opt));\n    (accessorFields(f) || []).forEach(_ => fmap[_] = 1);\n  });\n  return get.length === 0 ? null : accessor(gen(get, ord), Object.keys(fmap));\n}\nconst ascending = (u, v) => (u < v || u == null) && v != null ? -1 : (u > v || v == null) && u != null ? 1 : (v = v instanceof Date ? +v : v, u = u instanceof Date ? +u : u) !== u && v === v ? -1 : v !== v && u === u ? 1 : 0;\n\nconst comparator = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);\n\nconst compare1 = (field, order) => function (a, b) {\n  return ascending(field(a), field(b)) * order;\n};\n\nconst compareN = (fields, orders, n) => {\n  orders.push(0); // pad zero for convenient lookup\n\n  return function (a, b) {\n    let f,\n        c = 0,\n        i = -1;\n\n    while (c === 0 && ++i < n) {\n      f = fields[i];\n      c = ascending(f(a), f(b));\n    }\n\n    return c * orders[i];\n  };\n};\n\nfunction constant (_) {\n  return isFunction(_) ? _ : () => _;\n}\n\nfunction debounce (delay, handler) {\n  let tid;\n  return e => {\n    if (tid) clearTimeout(tid);\n    tid = setTimeout(() => (handler(e), tid = null), delay);\n  };\n}\n\nfunction extend (_) {\n  for (let x, k, i = 1, len = arguments.length; i < len; ++i) {\n    x = arguments[i];\n\n    for (k in x) {\n      _[k] = x[k];\n    }\n  }\n\n  return _;\n}\n\n/**\n * Return an array with minimum and maximum values, in the\n * form [min, max]. Ignores null, undefined, and NaN values.\n */\nfunction extent (array, f) {\n  let i = 0,\n      n,\n      v,\n      min,\n      max;\n\n  if (array && (n = array.length)) {\n    if (f == null) {\n      // find first valid value\n      for (v = array[i]; i < n && (v == null || v !== v); v = array[++i]);\n\n      min = max = v; // visit all other values\n\n      for (; i < n; ++i) {\n        v = array[i]; // skip null/undefined; NaN will fail all comparisons\n\n        if (v != null) {\n          if (v < min) min = v;\n          if (v > max) max = v;\n        }\n      }\n    } else {\n      // find first valid value\n      for (v = f(array[i]); i < n && (v == null || v !== v); v = f(array[++i]));\n\n      min = max = v; // visit all other values\n\n      for (; i < n; ++i) {\n        v = f(array[i]); // skip null/undefined; NaN will fail all comparisons\n\n        if (v != null) {\n          if (v < min) min = v;\n          if (v > max) max = v;\n        }\n      }\n    }\n  }\n\n  return [min, max];\n}\n\nfunction extentIndex (array, f) {\n  const n = array.length;\n  let i = -1,\n      a,\n      b,\n      c,\n      u,\n      v;\n\n  if (f == null) {\n    while (++i < n) {\n      b = array[i];\n\n      if (b != null && b >= b) {\n        a = c = b;\n        break;\n      }\n    }\n\n    if (i === n) return [-1, -1];\n    u = v = i;\n\n    while (++i < n) {\n      b = array[i];\n\n      if (b != null) {\n        if (a > b) {\n          a = b;\n          u = i;\n        }\n\n        if (c < b) {\n          c = b;\n          v = i;\n        }\n      }\n    }\n  } else {\n    while (++i < n) {\n      b = f(array[i], i, array);\n\n      if (b != null && b >= b) {\n        a = c = b;\n        break;\n      }\n    }\n\n    if (i === n) return [-1, -1];\n    u = v = i;\n\n    while (++i < n) {\n      b = f(array[i], i, array);\n\n      if (b != null) {\n        if (a > b) {\n          a = b;\n          u = i;\n        }\n\n        if (c < b) {\n          c = b;\n          v = i;\n        }\n      }\n    }\n  }\n\n  return [u, v];\n}\n\nconst hop = Object.prototype.hasOwnProperty;\nfunction has (object, property) {\n  return hop.call(object, property);\n}\n\nconst NULL = {};\nfunction fastmap (input) {\n  let obj = {},\n      test;\n\n  function has$1(key) {\n    return has(obj, key) && obj[key] !== NULL;\n  }\n\n  const map = {\n    size: 0,\n    empty: 0,\n    object: obj,\n    has: has$1,\n\n    get(key) {\n      return has$1(key) ? obj[key] : undefined;\n    },\n\n    set(key, value) {\n      if (!has$1(key)) {\n        ++map.size;\n        if (obj[key] === NULL) --map.empty;\n      }\n\n      obj[key] = value;\n      return this;\n    },\n\n    delete(key) {\n      if (has$1(key)) {\n        --map.size;\n        ++map.empty;\n        obj[key] = NULL;\n      }\n\n      return this;\n    },\n\n    clear() {\n      map.size = map.empty = 0;\n      map.object = obj = {};\n    },\n\n    test(_) {\n      if (arguments.length) {\n        test = _;\n        return map;\n      } else {\n        return test;\n      }\n    },\n\n    clean() {\n      const next = {};\n      let size = 0;\n\n      for (const key in obj) {\n        const value = obj[key];\n\n        if (value !== NULL && (!test || !test(value))) {\n          next[key] = value;\n          ++size;\n        }\n      }\n\n      map.size = size;\n      map.empty = 0;\n      map.object = obj = next;\n    }\n\n  };\n  if (input) Object.keys(input).forEach(key => {\n    map.set(key, input[key]);\n  });\n  return map;\n}\n\nfunction flush (range, value, threshold, left, right, center) {\n  if (!threshold && threshold !== 0) return center;\n  const t = +threshold;\n  let a = range[0],\n      b = peek(range),\n      l; // swap endpoints if range is reversed\n\n  if (b < a) {\n    l = a;\n    a = b;\n    b = l;\n  } // compare value to endpoints\n\n\n  l = Math.abs(value - a);\n  const r = Math.abs(b - value); // adjust if value is within threshold distance of endpoint\n\n  return l < r && l <= t ? left : r <= t ? right : center;\n}\n\nfunction inherits (child, parent, members) {\n  const proto = child.prototype = Object.create(parent.prototype);\n  proto.constructor = child;\n  return extend(proto, members);\n}\n\n/**\n * Predicate that returns true if the value lies within the span\n * of the given range. The left and right flags control the use\n * of inclusive (true) or exclusive (false) comparisons.\n */\nfunction inrange (value, range, left, right) {\n  let r0 = range[0],\n      r1 = range[range.length - 1],\n      t;\n\n  if (r0 > r1) {\n    t = r0;\n    r0 = r1;\n    r1 = t;\n  }\n\n  left = left === undefined || left;\n  right = right === undefined || right;\n  return (left ? r0 <= value : r0 < value) && (right ? value <= r1 : value < r1);\n}\n\nfunction isBoolean (_) {\n  return typeof _ === 'boolean';\n}\n\nfunction isDate (_) {\n  return Object.prototype.toString.call(_) === '[object Date]';\n}\n\nfunction isIterable (_) {\n  return _ && isFunction(_[Symbol.iterator]);\n}\n\nfunction isNumber (_) {\n  return typeof _ === 'number';\n}\n\nfunction isRegExp (_) {\n  return Object.prototype.toString.call(_) === '[object RegExp]';\n}\n\nfunction isString (_) {\n  return typeof _ === 'string';\n}\n\nfunction key (fields, flat, opt) {\n  if (fields) {\n    fields = flat ? array(fields).map(f => f.replace(/\\\\(.)/g, '$1')) : array(fields);\n  }\n\n  const len = fields && fields.length,\n        gen = opt && opt.get || getter,\n        map = f => gen(flat ? [f] : splitAccessPath(f));\n\n  let fn;\n\n  if (!len) {\n    fn = function () {\n      return '';\n    };\n  } else if (len === 1) {\n    const get = map(fields[0]);\n\n    fn = function (_) {\n      return '' + get(_);\n    };\n  } else {\n    const get = fields.map(map);\n\n    fn = function (_) {\n      let s = '' + get[0](_),\n          i = 0;\n\n      while (++i < len) s += '|' + get[i](_);\n\n      return s;\n    };\n  }\n\n  return accessor(fn, fields, 'key');\n}\n\nfunction lerp (array, frac) {\n  const lo = array[0],\n        hi = peek(array),\n        f = +frac;\n  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);\n}\n\nconst DEFAULT_MAX_SIZE = 10000; // adapted from https://github.com/dominictarr/hashlru/ (MIT License)\n\nfunction lruCache (maxsize) {\n  maxsize = +maxsize || DEFAULT_MAX_SIZE;\n  let curr, prev, size;\n\n  const clear = () => {\n    curr = {};\n    prev = {};\n    size = 0;\n  };\n\n  const update = (key, value) => {\n    if (++size > maxsize) {\n      prev = curr;\n      curr = {};\n      size = 1;\n    }\n\n    return curr[key] = value;\n  };\n\n  clear();\n  return {\n    clear,\n    has: key => has(curr, key) || has(prev, key),\n    get: key => has(curr, key) ? curr[key] : has(prev, key) ? update(key, prev[key]) : undefined,\n    set: (key, value) => has(curr, key) ? curr[key] = value : update(key, value)\n  };\n}\n\nfunction merge (compare, array0, array1, output) {\n  const n0 = array0.length,\n        n1 = array1.length;\n  if (!n1) return array0;\n  if (!n0) return array1;\n  const merged = output || new array0.constructor(n0 + n1);\n  let i0 = 0,\n      i1 = 0,\n      i = 0;\n\n  for (; i0 < n0 && i1 < n1; ++i) {\n    merged[i] = compare(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    merged[i] = array0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    merged[i] = array1[i1];\n  }\n\n  return merged;\n}\n\nfunction repeat (str, reps) {\n  let s = '';\n\n  while (--reps >= 0) s += str;\n\n  return s;\n}\n\nfunction pad (str, length, padchar, align) {\n  const c = padchar || ' ',\n        s = str + '',\n        n = length - s.length;\n  return n <= 0 ? s : align === 'left' ? repeat(c, n) + s : align === 'center' ? repeat(c, ~~(n / 2)) + s + repeat(c, Math.ceil(n / 2)) : s + repeat(c, n);\n}\n\n/**\n * Return the numerical span of an array: the difference between\n * the last and first values.\n */\n\nfunction span (array) {\n  return array && peek(array) - array[0] || 0;\n}\n\nfunction $(x) {\n  return isArray(x) ? '[' + x.map($) + ']' : isObject(x) || isString(x) ? // Output valid JSON and JS source strings.\n  // See http://timelessrepo.com/json-isnt-a-javascript-subset\n  JSON.stringify(x).replace('\\u2028', '\\\\u2028').replace('\\u2029', '\\\\u2029') : x;\n}\n\nfunction toBoolean (_) {\n  return _ == null || _ === '' ? null : !_ || _ === 'false' || _ === '0' ? false : !!_;\n}\n\nconst defaultParser = _ => isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);\n\nfunction toDate (_, parser) {\n  parser = parser || defaultParser;\n  return _ == null || _ === '' ? null : parser(_);\n}\n\nfunction toString (_) {\n  return _ == null || _ === '' ? null : _ + '';\n}\n\nfunction toSet (_) {\n  const s = {},\n        n = _.length;\n\n  for (let i = 0; i < n; ++i) s[_[i]] = true;\n\n  return s;\n}\n\nfunction truncate (str, length, align, ellipsis) {\n  const e = ellipsis != null ? ellipsis : '\\u2026',\n        s = str + '',\n        n = s.length,\n        l = Math.max(0, length - e.length);\n  return n <= length ? s : align === 'left' ? e + s.slice(n - l) : align === 'center' ? s.slice(0, Math.ceil(l / 2)) + e + s.slice(n - ~~(l / 2)) : s.slice(0, l) + e;\n}\n\nfunction visitArray (array, filter, visitor) {\n  if (array) {\n    if (filter) {\n      const n = array.length;\n\n      for (let i = 0; i < n; ++i) {\n        const t = filter(array[i]);\n        if (t) visitor(t, i, array);\n      }\n    } else {\n      array.forEach(visitor);\n    }\n  }\n}\n\nexport { Debug, Error$1 as Error, Info, None, Warn, accessor, accessorFields, accessorName, array, ascending, clampRange, compare, constant, debounce, error, extend, extent, extentIndex, falsy, fastmap, field, flush, has as hasOwnProperty, id, identity, inherits, inrange, isArray, isBoolean, isDate, isFunction, isIterable, isNumber, isObject, isRegExp, isString, key, lerp, logger, lruCache, merge, mergeConfig, one, pad, panLinear, panLog, panPow, panSymlog, peek, quarter, repeat, span, splitAccessPath, $ as stringValue, toBoolean, toDate, toNumber, toSet, toString, truncate, truthy, utcquarter, visitArray, writeConfig, zero, zoomLinear, zoomLog, zoomPow, zoomSymlog };\n","import { error, toSet, isFunction, isString, hasOwnProperty } from 'vega-util';\n\nconst RawCode = 'RawCode';\nconst Literal = 'Literal';\nconst Property = 'Property';\nconst Identifier = 'Identifier';\nconst ArrayExpression = 'ArrayExpression';\nconst BinaryExpression = 'BinaryExpression';\nconst CallExpression = 'CallExpression';\nconst ConditionalExpression = 'ConditionalExpression';\nconst LogicalExpression = 'LogicalExpression';\nconst MemberExpression = 'MemberExpression';\nconst ObjectExpression = 'ObjectExpression';\nconst UnaryExpression = 'UnaryExpression';\nfunction ASTNode(type) {\n  this.type = type;\n}\n\nASTNode.prototype.visit = function (visitor) {\n  let c, i, n;\n  if (visitor(this)) return 1;\n\n  for (c = children(this), i = 0, n = c.length; i < n; ++i) {\n    if (c[i].visit(visitor)) return 1;\n  }\n};\n\nfunction children(node) {\n  switch (node.type) {\n    case ArrayExpression:\n      return node.elements;\n\n    case BinaryExpression:\n    case LogicalExpression:\n      return [node.left, node.right];\n\n    case CallExpression:\n      return [node.callee].concat(node.arguments);\n\n    case ConditionalExpression:\n      return [node.test, node.consequent, node.alternate];\n\n    case MemberExpression:\n      return [node.object, node.property];\n\n    case ObjectExpression:\n      return node.properties;\n\n    case Property:\n      return [node.key, node.value];\n\n    case UnaryExpression:\n      return [node.argument];\n\n    case Identifier:\n    case Literal:\n    case RawCode:\n    default:\n      return [];\n  }\n}\n\n/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nvar TokenName, source, index, length, lookahead;\nvar TokenBooleanLiteral = 1,\n    TokenEOF = 2,\n    TokenIdentifier = 3,\n    TokenKeyword = 4,\n    TokenNullLiteral = 5,\n    TokenNumericLiteral = 6,\n    TokenPunctuator = 7,\n    TokenStringLiteral = 8,\n    TokenRegularExpression = 9;\nTokenName = {};\nTokenName[TokenBooleanLiteral] = 'Boolean';\nTokenName[TokenEOF] = '<end>';\nTokenName[TokenIdentifier] = 'Identifier';\nTokenName[TokenKeyword] = 'Keyword';\nTokenName[TokenNullLiteral] = 'Null';\nTokenName[TokenNumericLiteral] = 'Numeric';\nTokenName[TokenPunctuator] = 'Punctuator';\nTokenName[TokenStringLiteral] = 'String';\nTokenName[TokenRegularExpression] = 'RegularExpression';\nvar SyntaxArrayExpression = 'ArrayExpression',\n    SyntaxBinaryExpression = 'BinaryExpression',\n    SyntaxCallExpression = 'CallExpression',\n    SyntaxConditionalExpression = 'ConditionalExpression',\n    SyntaxIdentifier = 'Identifier',\n    SyntaxLiteral = 'Literal',\n    SyntaxLogicalExpression = 'LogicalExpression',\n    SyntaxMemberExpression = 'MemberExpression',\n    SyntaxObjectExpression = 'ObjectExpression',\n    SyntaxProperty = 'Property',\n    SyntaxUnaryExpression = 'UnaryExpression'; // Error messages should be identical to V8.\n\nvar MessageUnexpectedToken = 'Unexpected token %0',\n    MessageUnexpectedNumber = 'Unexpected number',\n    MessageUnexpectedString = 'Unexpected string',\n    MessageUnexpectedIdentifier = 'Unexpected identifier',\n    MessageUnexpectedReserved = 'Unexpected reserved word',\n    MessageUnexpectedEOS = 'Unexpected end of input',\n    MessageInvalidRegExp = 'Invalid regular expression',\n    MessageUnterminatedRegExp = 'Invalid regular expression: missing /',\n    MessageStrictOctalLiteral = 'Octal literals are not allowed in strict mode.',\n    MessageStrictDuplicateProperty = 'Duplicate data property in object literal not allowed in strict mode';\nvar ILLEGAL = 'ILLEGAL',\n    DISABLED = 'Disabled.'; // See also tools/generate-unicode-regex.py.\n\nvar RegexNonAsciiIdentifierStart = new RegExp('[\\\\xAA\\\\xB5\\\\xBA\\\\xC0-\\\\xD6\\\\xD8-\\\\xF6\\\\xF8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u037F\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u052F\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0620-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0800-\\\\u0815\\\\u081A\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08A0-\\\\u08B2\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0980\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0CF1\\\\u0CF2\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D3A\\\\u0D3D\\\\u0D4E\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC-\\\\u0EDF\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8C\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10C7\\\\u10CD\\\\u10D0-\\\\u10FA\\\\u10FC-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u167F\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u16EE-\\\\u16F8\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u18B0-\\\\u18F5\\\\u1900-\\\\u191E\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19AB\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1A20-\\\\u1A54\\\\u1AA7\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1BBA-\\\\u1BE5\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1CE9-\\\\u1CEC\\\\u1CEE-\\\\u1CF1\\\\u1CF5\\\\u1CF6\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u209C\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2160-\\\\u2188\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2CE4\\\\u2CEB-\\\\u2CEE\\\\u2CF2\\\\u2CF3\\\\u2D00-\\\\u2D25\\\\u2D27\\\\u2D2D\\\\u2D30-\\\\u2D67\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31BA\\\\u31F0-\\\\u31FF\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FCC\\\\uA000-\\\\uA48C\\\\uA4D0-\\\\uA4FD\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA66E\\\\uA67F-\\\\uA69D\\\\uA6A0-\\\\uA6EF\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B-\\\\uA78E\\\\uA790-\\\\uA7AD\\\\uA7B0\\\\uA7B1\\\\uA7F7-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA8F2-\\\\uA8F7\\\\uA8FB\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uA960-\\\\uA97C\\\\uA984-\\\\uA9B2\\\\uA9CF\\\\uA9E0-\\\\uA9E4\\\\uA9E6-\\\\uA9EF\\\\uA9FA-\\\\uA9FE\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAA60-\\\\uAA76\\\\uAA7A\\\\uAA7E-\\\\uAAAF\\\\uAAB1\\\\uAAB5\\\\uAAB6\\\\uAAB9-\\\\uAABD\\\\uAAC0\\\\uAAC2\\\\uAADB-\\\\uAADD\\\\uAAE0-\\\\uAAEA\\\\uAAF2-\\\\uAAF4\\\\uAB01-\\\\uAB06\\\\uAB09-\\\\uAB0E\\\\uAB11-\\\\uAB16\\\\uAB20-\\\\uAB26\\\\uAB28-\\\\uAB2E\\\\uAB30-\\\\uAB5A\\\\uAB5C-\\\\uAB5F\\\\uAB64\\\\uAB65\\\\uABC0-\\\\uABE2\\\\uAC00-\\\\uD7A3\\\\uD7B0-\\\\uD7C6\\\\uD7CB-\\\\uD7FB\\\\uF900-\\\\uFA6D\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]'),\n    // eslint-disable-next-line no-misleading-character-class\nRegexNonAsciiIdentifierPart = new RegExp('[\\\\xAA\\\\xB5\\\\xBA\\\\xC0-\\\\xD6\\\\xD8-\\\\xF6\\\\xF8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0300-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u037F\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u0483-\\\\u0487\\\\u048A-\\\\u052F\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0610-\\\\u061A\\\\u0620-\\\\u0669\\\\u066E-\\\\u06D3\\\\u06D5-\\\\u06DC\\\\u06DF-\\\\u06E8\\\\u06EA-\\\\u06FC\\\\u06FF\\\\u0710-\\\\u074A\\\\u074D-\\\\u07B1\\\\u07C0-\\\\u07F5\\\\u07FA\\\\u0800-\\\\u082D\\\\u0840-\\\\u085B\\\\u08A0-\\\\u08B2\\\\u08E4-\\\\u0963\\\\u0966-\\\\u096F\\\\u0971-\\\\u0983\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BC-\\\\u09C4\\\\u09C7\\\\u09C8\\\\u09CB-\\\\u09CE\\\\u09D7\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E3\\\\u09E6-\\\\u09F1\\\\u0A01-\\\\u0A03\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A3C\\\\u0A3E-\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A66-\\\\u0A75\\\\u0A81-\\\\u0A83\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABC-\\\\u0AC5\\\\u0AC7-\\\\u0AC9\\\\u0ACB-\\\\u0ACD\\\\u0AD0\\\\u0AE0-\\\\u0AE3\\\\u0AE6-\\\\u0AEF\\\\u0B01-\\\\u0B03\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3C-\\\\u0B44\\\\u0B47\\\\u0B48\\\\u0B4B-\\\\u0B4D\\\\u0B56\\\\u0B57\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B63\\\\u0B66-\\\\u0B6F\\\\u0B71\\\\u0B82\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BBE-\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCD\\\\u0BD0\\\\u0BD7\\\\u0BE6-\\\\u0BEF\\\\u0C00-\\\\u0C03\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C39\\\\u0C3D-\\\\u0C44\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C58\\\\u0C59\\\\u0C60-\\\\u0C63\\\\u0C66-\\\\u0C6F\\\\u0C81-\\\\u0C83\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBC-\\\\u0CC4\\\\u0CC6-\\\\u0CC8\\\\u0CCA-\\\\u0CCD\\\\u0CD5\\\\u0CD6\\\\u0CDE\\\\u0CE0-\\\\u0CE3\\\\u0CE6-\\\\u0CEF\\\\u0CF1\\\\u0CF2\\\\u0D01-\\\\u0D03\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D3A\\\\u0D3D-\\\\u0D44\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4E\\\\u0D57\\\\u0D60-\\\\u0D63\\\\u0D66-\\\\u0D6F\\\\u0D7A-\\\\u0D7F\\\\u0D82\\\\u0D83\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0DCA\\\\u0DCF-\\\\u0DD4\\\\u0DD6\\\\u0DD8-\\\\u0DDF\\\\u0DE6-\\\\u0DEF\\\\u0DF2\\\\u0DF3\\\\u0E01-\\\\u0E3A\\\\u0E40-\\\\u0E4E\\\\u0E50-\\\\u0E59\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB9\\\\u0EBB-\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EC8-\\\\u0ECD\\\\u0ED0-\\\\u0ED9\\\\u0EDC-\\\\u0EDF\\\\u0F00\\\\u0F18\\\\u0F19\\\\u0F20-\\\\u0F29\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F3E-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F71-\\\\u0F84\\\\u0F86-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u1000-\\\\u1049\\\\u1050-\\\\u109D\\\\u10A0-\\\\u10C5\\\\u10C7\\\\u10CD\\\\u10D0-\\\\u10FA\\\\u10FC-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u135D-\\\\u135F\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u167F\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u16EE-\\\\u16F8\\\\u1700-\\\\u170C\\\\u170E-\\\\u1714\\\\u1720-\\\\u1734\\\\u1740-\\\\u1753\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1772\\\\u1773\\\\u1780-\\\\u17D3\\\\u17D7\\\\u17DC\\\\u17DD\\\\u17E0-\\\\u17E9\\\\u180B-\\\\u180D\\\\u1810-\\\\u1819\\\\u1820-\\\\u1877\\\\u1880-\\\\u18AA\\\\u18B0-\\\\u18F5\\\\u1900-\\\\u191E\\\\u1920-\\\\u192B\\\\u1930-\\\\u193B\\\\u1946-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19AB\\\\u19B0-\\\\u19C9\\\\u19D0-\\\\u19D9\\\\u1A00-\\\\u1A1B\\\\u1A20-\\\\u1A5E\\\\u1A60-\\\\u1A7C\\\\u1A7F-\\\\u1A89\\\\u1A90-\\\\u1A99\\\\u1AA7\\\\u1AB0-\\\\u1ABD\\\\u1B00-\\\\u1B4B\\\\u1B50-\\\\u1B59\\\\u1B6B-\\\\u1B73\\\\u1B80-\\\\u1BF3\\\\u1C00-\\\\u1C37\\\\u1C40-\\\\u1C49\\\\u1C4D-\\\\u1C7D\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CF6\\\\u1CF8\\\\u1CF9\\\\u1D00-\\\\u1DF5\\\\u1DFC-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u200C\\\\u200D\\\\u203F\\\\u2040\\\\u2054\\\\u2071\\\\u207F\\\\u2090-\\\\u209C\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2160-\\\\u2188\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2CE4\\\\u2CEB-\\\\u2CF3\\\\u2D00-\\\\u2D25\\\\u2D27\\\\u2D2D\\\\u2D30-\\\\u2D67\\\\u2D6F\\\\u2D7F-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2DE0-\\\\u2DFF\\\\u2E2F\\\\u3005-\\\\u3007\\\\u3021-\\\\u302F\\\\u3031-\\\\u3035\\\\u3038-\\\\u303C\\\\u3041-\\\\u3096\\\\u3099\\\\u309A\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31BA\\\\u31F0-\\\\u31FF\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FCC\\\\uA000-\\\\uA48C\\\\uA4D0-\\\\uA4FD\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA62B\\\\uA640-\\\\uA66F\\\\uA674-\\\\uA67D\\\\uA67F-\\\\uA69D\\\\uA69F-\\\\uA6F1\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B-\\\\uA78E\\\\uA790-\\\\uA7AD\\\\uA7B0\\\\uA7B1\\\\uA7F7-\\\\uA827\\\\uA840-\\\\uA873\\\\uA880-\\\\uA8C4\\\\uA8D0-\\\\uA8D9\\\\uA8E0-\\\\uA8F7\\\\uA8FB\\\\uA900-\\\\uA92D\\\\uA930-\\\\uA953\\\\uA960-\\\\uA97C\\\\uA980-\\\\uA9C0\\\\uA9CF-\\\\uA9D9\\\\uA9E0-\\\\uA9FE\\\\uAA00-\\\\uAA36\\\\uAA40-\\\\uAA4D\\\\uAA50-\\\\uAA59\\\\uAA60-\\\\uAA76\\\\uAA7A-\\\\uAAC2\\\\uAADB-\\\\uAADD\\\\uAAE0-\\\\uAAEF\\\\uAAF2-\\\\uAAF6\\\\uAB01-\\\\uAB06\\\\uAB09-\\\\uAB0E\\\\uAB11-\\\\uAB16\\\\uAB20-\\\\uAB26\\\\uAB28-\\\\uAB2E\\\\uAB30-\\\\uAB5A\\\\uAB5C-\\\\uAB5F\\\\uAB64\\\\uAB65\\\\uABC0-\\\\uABEA\\\\uABEC\\\\uABED\\\\uABF0-\\\\uABF9\\\\uAC00-\\\\uD7A3\\\\uD7B0-\\\\uD7C6\\\\uD7CB-\\\\uD7FB\\\\uF900-\\\\uFA6D\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE2D\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF10-\\\\uFF19\\\\uFF21-\\\\uFF3A\\\\uFF3F\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]'); // Ensure the condition is true, otherwise throw an error.\n// This is only to have a better contract semantic, i.e. another safety net\n// to catch a logic error. The condition shall be fulfilled in normal case.\n// Do NOT use this to enforce a certain condition on any user input.\n\nfunction assert(condition, message) {\n  /* istanbul ignore next */\n  if (!condition) {\n    throw new Error('ASSERT: ' + message);\n  }\n}\n\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 && ch <= 0x39; // 0..9\n}\n\nfunction isHexDigit(ch) {\n  return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n}\n\nfunction isOctalDigit(ch) {\n  return '01234567'.indexOf(ch) >= 0;\n} // 7.2 White Space\n\n\nfunction isWhiteSpace(ch) {\n  return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;\n} // 7.3 Line Terminators\n\n\nfunction isLineTerminator(ch) {\n  return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;\n} // 7.6 Identifier Names and Identifiers\n\n\nfunction isIdentifierStart(ch) {\n  return ch === 0x24 || ch === 0x5F || // $ (dollar) and _ (underscore)\n  ch >= 0x41 && ch <= 0x5A || // A..Z\n  ch >= 0x61 && ch <= 0x7A || // a..z\n  ch === 0x5C || // \\ (backslash)\n  ch >= 0x80 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch));\n}\n\nfunction isIdentifierPart(ch) {\n  return ch === 0x24 || ch === 0x5F || // $ (dollar) and _ (underscore)\n  ch >= 0x41 && ch <= 0x5A || // A..Z\n  ch >= 0x61 && ch <= 0x7A || // a..z\n  ch >= 0x30 && ch <= 0x39 || // 0..9\n  ch === 0x5C || // \\ (backslash)\n  ch >= 0x80 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch));\n} // 7.6.1.1 Keywords\n\n\nconst keywords = {\n  'if': 1,\n  'in': 1,\n  'do': 1,\n  'var': 1,\n  'for': 1,\n  'new': 1,\n  'try': 1,\n  'let': 1,\n  'this': 1,\n  'else': 1,\n  'case': 1,\n  'void': 1,\n  'with': 1,\n  'enum': 1,\n  'while': 1,\n  'break': 1,\n  'catch': 1,\n  'throw': 1,\n  'const': 1,\n  'yield': 1,\n  'class': 1,\n  'super': 1,\n  'return': 1,\n  'typeof': 1,\n  'delete': 1,\n  'switch': 1,\n  'export': 1,\n  'import': 1,\n  'public': 1,\n  'static': 1,\n  'default': 1,\n  'finally': 1,\n  'extends': 1,\n  'package': 1,\n  'private': 1,\n  'function': 1,\n  'continue': 1,\n  'debugger': 1,\n  'interface': 1,\n  'protected': 1,\n  'instanceof': 1,\n  'implements': 1\n};\n\nfunction skipComment() {\n  while (index < length) {\n    const ch = source.charCodeAt(index);\n\n    if (isWhiteSpace(ch) || isLineTerminator(ch)) {\n      ++index;\n    } else {\n      break;\n    }\n  }\n}\n\nfunction scanHexEscape(prefix) {\n  var i,\n      len,\n      ch,\n      code = 0;\n  len = prefix === 'u' ? 4 : 2;\n\n  for (i = 0; i < len; ++i) {\n    if (index < length && isHexDigit(source[index])) {\n      ch = source[index++];\n      code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n    } else {\n      throwError({}, MessageUnexpectedToken, ILLEGAL);\n    }\n  }\n\n  return String.fromCharCode(code);\n}\n\nfunction scanUnicodeCodePointEscape() {\n  var ch, code, cu1, cu2;\n  ch = source[index];\n  code = 0; // At least, one hex digit is required.\n\n  if (ch === '}') {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  while (index < length) {\n    ch = source[index++];\n\n    if (!isHexDigit(ch)) {\n      break;\n    }\n\n    code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n  }\n\n  if (code > 0x10FFFF || ch !== '}') {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  } // UTF-16 Encoding\n\n\n  if (code <= 0xFFFF) {\n    return String.fromCharCode(code);\n  }\n\n  cu1 = (code - 0x10000 >> 10) + 0xD800;\n  cu2 = (code - 0x10000 & 1023) + 0xDC00;\n  return String.fromCharCode(cu1, cu2);\n}\n\nfunction getEscapedIdentifier() {\n  var ch, id;\n  ch = source.charCodeAt(index++);\n  id = String.fromCharCode(ch); // '\\u' (U+005C, U+0075) denotes an escaped character.\n\n  if (ch === 0x5C) {\n    if (source.charCodeAt(index) !== 0x75) {\n      throwError({}, MessageUnexpectedToken, ILLEGAL);\n    }\n\n    ++index;\n    ch = scanHexEscape('u');\n\n    if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n      throwError({}, MessageUnexpectedToken, ILLEGAL);\n    }\n\n    id = ch;\n  }\n\n  while (index < length) {\n    ch = source.charCodeAt(index);\n\n    if (!isIdentifierPart(ch)) {\n      break;\n    }\n\n    ++index;\n    id += String.fromCharCode(ch); // '\\u' (U+005C, U+0075) denotes an escaped character.\n\n    if (ch === 0x5C) {\n      id = id.substr(0, id.length - 1);\n\n      if (source.charCodeAt(index) !== 0x75) {\n        throwError({}, MessageUnexpectedToken, ILLEGAL);\n      }\n\n      ++index;\n      ch = scanHexEscape('u');\n\n      if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n        throwError({}, MessageUnexpectedToken, ILLEGAL);\n      }\n\n      id += ch;\n    }\n  }\n\n  return id;\n}\n\nfunction getIdentifier() {\n  var start, ch;\n  start = index++;\n\n  while (index < length) {\n    ch = source.charCodeAt(index);\n\n    if (ch === 0x5C) {\n      // Blackslash (U+005C) marks Unicode escape sequence.\n      index = start;\n      return getEscapedIdentifier();\n    }\n\n    if (isIdentifierPart(ch)) {\n      ++index;\n    } else {\n      break;\n    }\n  }\n\n  return source.slice(start, index);\n}\n\nfunction scanIdentifier() {\n  var start, id, type;\n  start = index; // Backslash (U+005C) starts an escaped character.\n\n  id = source.charCodeAt(index) === 0x5C ? getEscapedIdentifier() : getIdentifier(); // There is no keyword or literal with only one character.\n  // Thus, it must be an identifier.\n\n  if (id.length === 1) {\n    type = TokenIdentifier;\n  } else if (keywords.hasOwnProperty(id)) {\n    // eslint-disable-line no-prototype-builtins\n    type = TokenKeyword;\n  } else if (id === 'null') {\n    type = TokenNullLiteral;\n  } else if (id === 'true' || id === 'false') {\n    type = TokenBooleanLiteral;\n  } else {\n    type = TokenIdentifier;\n  }\n\n  return {\n    type: type,\n    value: id,\n    start: start,\n    end: index\n  };\n} // 7.7 Punctuators\n\n\nfunction scanPunctuator() {\n  var start = index,\n      code = source.charCodeAt(index),\n      code2,\n      ch1 = source[index],\n      ch2,\n      ch3,\n      ch4;\n\n  switch (code) {\n    // Check for most common single-character punctuators.\n    case 0x2E: // . dot\n\n    case 0x28: // ( open bracket\n\n    case 0x29: // ) close bracket\n\n    case 0x3B: // ; semicolon\n\n    case 0x2C: // , comma\n\n    case 0x7B: // { open curly brace\n\n    case 0x7D: // } close curly brace\n\n    case 0x5B: // [\n\n    case 0x5D: // ]\n\n    case 0x3A: // :\n\n    case 0x3F: // ?\n\n    case 0x7E:\n      // ~\n      ++index;\n      return {\n        type: TokenPunctuator,\n        value: String.fromCharCode(code),\n        start: start,\n        end: index\n      };\n\n    default:\n      code2 = source.charCodeAt(index + 1); // '=' (U+003D) marks an assignment or comparison operator.\n\n      if (code2 === 0x3D) {\n        switch (code) {\n          case 0x2B: // +\n\n          case 0x2D: // -\n\n          case 0x2F: // /\n\n          case 0x3C: // <\n\n          case 0x3E: // >\n\n          case 0x5E: // ^\n\n          case 0x7C: // |\n\n          case 0x25: // %\n\n          case 0x26: // &\n\n          case 0x2A:\n            // *\n            index += 2;\n            return {\n              type: TokenPunctuator,\n              value: String.fromCharCode(code) + String.fromCharCode(code2),\n              start: start,\n              end: index\n            };\n\n          case 0x21: // !\n\n          case 0x3D:\n            // =\n            index += 2; // !== and ===\n\n            if (source.charCodeAt(index) === 0x3D) {\n              ++index;\n            }\n\n            return {\n              type: TokenPunctuator,\n              value: source.slice(start, index),\n              start: start,\n              end: index\n            };\n        }\n      }\n\n  } // 4-character punctuator: >>>=\n\n\n  ch4 = source.substr(index, 4);\n\n  if (ch4 === '>>>=') {\n    index += 4;\n    return {\n      type: TokenPunctuator,\n      value: ch4,\n      start: start,\n      end: index\n    };\n  } // 3-character punctuators: === !== >>> <<= >>=\n\n\n  ch3 = ch4.substr(0, 3);\n\n  if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n    index += 3;\n    return {\n      type: TokenPunctuator,\n      value: ch3,\n      start: start,\n      end: index\n    };\n  } // Other 2-character punctuators: ++ -- << >> && ||\n\n\n  ch2 = ch3.substr(0, 2);\n\n  if (ch1 === ch2[1] && '+-<>&|'.indexOf(ch1) >= 0 || ch2 === '=>') {\n    index += 2;\n    return {\n      type: TokenPunctuator,\n      value: ch2,\n      start: start,\n      end: index\n    };\n  }\n\n  if (ch2 === '//') {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  } // 1-character punctuators: < > = ! + - * % & | ^ /\n\n\n  if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n    ++index;\n    return {\n      type: TokenPunctuator,\n      value: ch1,\n      start: start,\n      end: index\n    };\n  }\n\n  throwError({}, MessageUnexpectedToken, ILLEGAL);\n} // 7.8.3 Numeric Literals\n\n\nfunction scanHexLiteral(start) {\n  let number = '';\n\n  while (index < length) {\n    if (!isHexDigit(source[index])) {\n      break;\n    }\n\n    number += source[index++];\n  }\n\n  if (number.length === 0) {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  if (isIdentifierStart(source.charCodeAt(index))) {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  return {\n    type: TokenNumericLiteral,\n    value: parseInt('0x' + number, 16),\n    start: start,\n    end: index\n  };\n}\n\nfunction scanOctalLiteral(start) {\n  let number = '0' + source[index++];\n\n  while (index < length) {\n    if (!isOctalDigit(source[index])) {\n      break;\n    }\n\n    number += source[index++];\n  }\n\n  if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  return {\n    type: TokenNumericLiteral,\n    value: parseInt(number, 8),\n    octal: true,\n    start: start,\n    end: index\n  };\n}\n\nfunction scanNumericLiteral() {\n  var number, start, ch;\n  ch = source[index];\n  assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');\n  start = index;\n  number = '';\n\n  if (ch !== '.') {\n    number = source[index++];\n    ch = source[index]; // Hex number starts with '0x'.\n    // Octal number starts with '0'.\n\n    if (number === '0') {\n      if (ch === 'x' || ch === 'X') {\n        ++index;\n        return scanHexLiteral(start);\n      }\n\n      if (isOctalDigit(ch)) {\n        return scanOctalLiteral(start);\n      } // decimal number starts with '0' such as '09' is illegal.\n\n\n      if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n        throwError({}, MessageUnexpectedToken, ILLEGAL);\n      }\n    }\n\n    while (isDecimalDigit(source.charCodeAt(index))) {\n      number += source[index++];\n    }\n\n    ch = source[index];\n  }\n\n  if (ch === '.') {\n    number += source[index++];\n\n    while (isDecimalDigit(source.charCodeAt(index))) {\n      number += source[index++];\n    }\n\n    ch = source[index];\n  }\n\n  if (ch === 'e' || ch === 'E') {\n    number += source[index++];\n    ch = source[index];\n\n    if (ch === '+' || ch === '-') {\n      number += source[index++];\n    }\n\n    if (isDecimalDigit(source.charCodeAt(index))) {\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n    } else {\n      throwError({}, MessageUnexpectedToken, ILLEGAL);\n    }\n  }\n\n  if (isIdentifierStart(source.charCodeAt(index))) {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  return {\n    type: TokenNumericLiteral,\n    value: parseFloat(number),\n    start: start,\n    end: index\n  };\n} // 7.8.4 String Literals\n\n\nfunction scanStringLiteral() {\n  var str = '',\n      quote,\n      start,\n      ch,\n      code,\n      octal = false;\n  quote = source[index];\n  assert(quote === '\\'' || quote === '\"', 'String literal must starts with a quote');\n  start = index;\n  ++index;\n\n  while (index < length) {\n    ch = source[index++];\n\n    if (ch === quote) {\n      quote = '';\n      break;\n    } else if (ch === '\\\\') {\n      ch = source[index++];\n\n      if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n        switch (ch) {\n          case 'u':\n          case 'x':\n            if (source[index] === '{') {\n              ++index;\n              str += scanUnicodeCodePointEscape();\n            } else {\n              str += scanHexEscape(ch);\n            }\n\n            break;\n\n          case 'n':\n            str += '\\n';\n            break;\n\n          case 'r':\n            str += '\\r';\n            break;\n\n          case 't':\n            str += '\\t';\n            break;\n\n          case 'b':\n            str += '\\b';\n            break;\n\n          case 'f':\n            str += '\\f';\n            break;\n\n          case 'v':\n            str += '\\x0B';\n            break;\n\n          default:\n            if (isOctalDigit(ch)) {\n              code = '01234567'.indexOf(ch); // \\0 is not octal escape sequence\n\n              if (code !== 0) {\n                octal = true;\n              }\n\n              if (index < length && isOctalDigit(source[index])) {\n                octal = true;\n                code = code * 8 + '01234567'.indexOf(source[index++]); // 3 digits are only allowed when string starts\n                // with 0, 1, 2, 3\n\n                if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                }\n              }\n\n              str += String.fromCharCode(code);\n            } else {\n              str += ch;\n            }\n\n            break;\n        }\n      } else {\n        if (ch === '\\r' && source[index] === '\\n') {\n          ++index;\n        }\n      }\n    } else if (isLineTerminator(ch.charCodeAt(0))) {\n      break;\n    } else {\n      str += ch;\n    }\n  }\n\n  if (quote !== '') {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  return {\n    type: TokenStringLiteral,\n    value: str,\n    octal: octal,\n    start: start,\n    end: index\n  };\n}\n\nfunction testRegExp(pattern, flags) {\n  let tmp = pattern;\n\n  if (flags.indexOf('u') >= 0) {\n    // Replace each astral symbol and every Unicode code point\n    // escape sequence with a single ASCII symbol to avoid throwing on\n    // regular expressions that are only valid in combination with the\n    // `/u` flag.\n    // Note: replacing with the ASCII symbol `x` might cause false\n    // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n    // perfectly valid pattern that is equivalent to `[a-b]`, but it\n    // would be replaced by `[x-b]` which throws an error.\n    tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, ($0, $1) => {\n      if (parseInt($1, 16) <= 0x10FFFF) {\n        return 'x';\n      }\n\n      throwError({}, MessageInvalidRegExp);\n    }).replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n  } // First, detect invalid regular expressions.\n\n\n  try {\n    new RegExp(tmp);\n  } catch (e) {\n    throwError({}, MessageInvalidRegExp);\n  } // Return a regular expression object for this pattern-flag pair, or\n  // `null` in case the current environment doesn't support the flags it\n  // uses.\n\n\n  try {\n    return new RegExp(pattern, flags);\n  } catch (exception) {\n    return null;\n  }\n}\n\nfunction scanRegExpBody() {\n  var ch, str, classMarker, terminated, body;\n  ch = source[index];\n  assert(ch === '/', 'Regular expression literal must start with a slash');\n  str = source[index++];\n  classMarker = false;\n  terminated = false;\n\n  while (index < length) {\n    ch = source[index++];\n    str += ch;\n\n    if (ch === '\\\\') {\n      ch = source[index++]; // ECMA-262 7.8.5\n\n      if (isLineTerminator(ch.charCodeAt(0))) {\n        throwError({}, MessageUnterminatedRegExp);\n      }\n\n      str += ch;\n    } else if (isLineTerminator(ch.charCodeAt(0))) {\n      throwError({}, MessageUnterminatedRegExp);\n    } else if (classMarker) {\n      if (ch === ']') {\n        classMarker = false;\n      }\n    } else {\n      if (ch === '/') {\n        terminated = true;\n        break;\n      } else if (ch === '[') {\n        classMarker = true;\n      }\n    }\n  }\n\n  if (!terminated) {\n    throwError({}, MessageUnterminatedRegExp);\n  } // Exclude leading and trailing slash.\n\n\n  body = str.substr(1, str.length - 2);\n  return {\n    value: body,\n    literal: str\n  };\n}\n\nfunction scanRegExpFlags() {\n  var ch, str, flags;\n  str = '';\n  flags = '';\n\n  while (index < length) {\n    ch = source[index];\n\n    if (!isIdentifierPart(ch.charCodeAt(0))) {\n      break;\n    }\n\n    ++index;\n\n    if (ch === '\\\\' && index < length) {\n      throwError({}, MessageUnexpectedToken, ILLEGAL);\n    } else {\n      flags += ch;\n      str += ch;\n    }\n  }\n\n  if (flags.search(/[^gimuy]/g) >= 0) {\n    throwError({}, MessageInvalidRegExp, flags);\n  }\n\n  return {\n    value: flags,\n    literal: str\n  };\n}\n\nfunction scanRegExp() {\n  var start, body, flags, value;\n  lookahead = null;\n  skipComment();\n  start = index;\n  body = scanRegExpBody();\n  flags = scanRegExpFlags();\n  value = testRegExp(body.value, flags.value);\n  return {\n    literal: body.literal + flags.literal,\n    value: value,\n    regex: {\n      pattern: body.value,\n      flags: flags.value\n    },\n    start: start,\n    end: index\n  };\n}\n\nfunction isIdentifierName(token) {\n  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;\n}\n\nfunction advance() {\n  skipComment();\n\n  if (index >= length) {\n    return {\n      type: TokenEOF,\n      start: index,\n      end: index\n    };\n  }\n\n  const ch = source.charCodeAt(index);\n\n  if (isIdentifierStart(ch)) {\n    return scanIdentifier();\n  } // Very common: ( and ) and ;\n\n\n  if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n    return scanPunctuator();\n  } // String literal starts with single quote (U+0027) or double quote (U+0022).\n\n\n  if (ch === 0x27 || ch === 0x22) {\n    return scanStringLiteral();\n  } // Dot (.) U+002E can also start a floating-point number, hence the need\n  // to check the next character.\n\n\n  if (ch === 0x2E) {\n    if (isDecimalDigit(source.charCodeAt(index + 1))) {\n      return scanNumericLiteral();\n    }\n\n    return scanPunctuator();\n  }\n\n  if (isDecimalDigit(ch)) {\n    return scanNumericLiteral();\n  }\n\n  return scanPunctuator();\n}\n\nfunction lex() {\n  const token = lookahead;\n  index = token.end;\n  lookahead = advance();\n  index = token.end;\n  return token;\n}\n\nfunction peek() {\n  const pos = index;\n  lookahead = advance();\n  index = pos;\n}\n\nfunction finishArrayExpression(elements) {\n  const node = new ASTNode(SyntaxArrayExpression);\n  node.elements = elements;\n  return node;\n}\n\nfunction finishBinaryExpression(operator, left, right) {\n  const node = new ASTNode(operator === '||' || operator === '&&' ? SyntaxLogicalExpression : SyntaxBinaryExpression);\n  node.operator = operator;\n  node.left = left;\n  node.right = right;\n  return node;\n}\n\nfunction finishCallExpression(callee, args) {\n  const node = new ASTNode(SyntaxCallExpression);\n  node.callee = callee;\n  node.arguments = args;\n  return node;\n}\n\nfunction finishConditionalExpression(test, consequent, alternate) {\n  const node = new ASTNode(SyntaxConditionalExpression);\n  node.test = test;\n  node.consequent = consequent;\n  node.alternate = alternate;\n  return node;\n}\n\nfunction finishIdentifier(name) {\n  const node = new ASTNode(SyntaxIdentifier);\n  node.name = name;\n  return node;\n}\n\nfunction finishLiteral(token) {\n  const node = new ASTNode(SyntaxLiteral);\n  node.value = token.value;\n  node.raw = source.slice(token.start, token.end);\n\n  if (token.regex) {\n    if (node.raw === '//') {\n      node.raw = '/(?:)/';\n    }\n\n    node.regex = token.regex;\n  }\n\n  return node;\n}\n\nfunction finishMemberExpression(accessor, object, property) {\n  const node = new ASTNode(SyntaxMemberExpression);\n  node.computed = accessor === '[';\n  node.object = object;\n  node.property = property;\n  if (!node.computed) property.member = true;\n  return node;\n}\n\nfunction finishObjectExpression(properties) {\n  const node = new ASTNode(SyntaxObjectExpression);\n  node.properties = properties;\n  return node;\n}\n\nfunction finishProperty(kind, key, value) {\n  const node = new ASTNode(SyntaxProperty);\n  node.key = key;\n  node.value = value;\n  node.kind = kind;\n  return node;\n}\n\nfunction finishUnaryExpression(operator, argument) {\n  const node = new ASTNode(SyntaxUnaryExpression);\n  node.operator = operator;\n  node.argument = argument;\n  node.prefix = true;\n  return node;\n} // Throw an exception\n\n\nfunction throwError(token, messageFormat) {\n  var error,\n      args = Array.prototype.slice.call(arguments, 2),\n      msg = messageFormat.replace(/%(\\d)/g, (whole, index) => {\n    assert(index < args.length, 'Message reference must be in range');\n    return args[index];\n  });\n  error = new Error(msg);\n  error.index = index;\n  error.description = msg;\n  throw error;\n} // Throw an exception because of the token.\n\n\nfunction throwUnexpected(token) {\n  if (token.type === TokenEOF) {\n    throwError(token, MessageUnexpectedEOS);\n  }\n\n  if (token.type === TokenNumericLiteral) {\n    throwError(token, MessageUnexpectedNumber);\n  }\n\n  if (token.type === TokenStringLiteral) {\n    throwError(token, MessageUnexpectedString);\n  }\n\n  if (token.type === TokenIdentifier) {\n    throwError(token, MessageUnexpectedIdentifier);\n  }\n\n  if (token.type === TokenKeyword) {\n    throwError(token, MessageUnexpectedReserved);\n  } // BooleanLiteral, NullLiteral, or Punctuator.\n\n\n  throwError(token, MessageUnexpectedToken, token.value);\n} // Expect the next token to match the specified punctuator.\n// If not, an exception will be thrown.\n\n\nfunction expect(value) {\n  const token = lex();\n\n  if (token.type !== TokenPunctuator || token.value !== value) {\n    throwUnexpected(token);\n  }\n} // Return true if the next token matches the specified punctuator.\n\n\nfunction match(value) {\n  return lookahead.type === TokenPunctuator && lookahead.value === value;\n} // Return true if the next token matches the specified keyword\n\n\nfunction matchKeyword(keyword) {\n  return lookahead.type === TokenKeyword && lookahead.value === keyword;\n} // 11.1.4 Array Initialiser\n\n\nfunction parseArrayInitialiser() {\n  const elements = [];\n  index = lookahead.start;\n  expect('[');\n\n  while (!match(']')) {\n    if (match(',')) {\n      lex();\n      elements.push(null);\n    } else {\n      elements.push(parseConditionalExpression());\n\n      if (!match(']')) {\n        expect(',');\n      }\n    }\n  }\n\n  lex();\n  return finishArrayExpression(elements);\n} // 11.1.5 Object Initialiser\n\n\nfunction parseObjectPropertyKey() {\n  index = lookahead.start;\n  const token = lex(); // Note: This function is called only from parseObjectProperty(), where\n  // EOF and Punctuator tokens are already filtered out.\n\n  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {\n    if (token.octal) {\n      throwError(token, MessageStrictOctalLiteral);\n    }\n\n    return finishLiteral(token);\n  }\n\n  return finishIdentifier(token.value);\n}\n\nfunction parseObjectProperty() {\n  var token, key, id, value;\n  index = lookahead.start;\n  token = lookahead;\n\n  if (token.type === TokenIdentifier) {\n    id = parseObjectPropertyKey();\n    expect(':');\n    value = parseConditionalExpression();\n    return finishProperty('init', id, value);\n  }\n\n  if (token.type === TokenEOF || token.type === TokenPunctuator) {\n    throwUnexpected(token);\n  } else {\n    key = parseObjectPropertyKey();\n    expect(':');\n    value = parseConditionalExpression();\n    return finishProperty('init', key, value);\n  }\n}\n\nfunction parseObjectInitialiser() {\n  var properties = [],\n      property,\n      name,\n      key,\n      map = {},\n      toString = String;\n  index = lookahead.start;\n  expect('{');\n\n  while (!match('}')) {\n    property = parseObjectProperty();\n\n    if (property.key.type === SyntaxIdentifier) {\n      name = property.key.name;\n    } else {\n      name = toString(property.key.value);\n    }\n\n    key = '$' + name;\n\n    if (Object.prototype.hasOwnProperty.call(map, key)) {\n      throwError({}, MessageStrictDuplicateProperty);\n    } else {\n      map[key] = true;\n    }\n\n    properties.push(property);\n\n    if (!match('}')) {\n      expect(',');\n    }\n  }\n\n  expect('}');\n  return finishObjectExpression(properties);\n} // 11.1.6 The Grouping Operator\n\n\nfunction parseGroupExpression() {\n  expect('(');\n  const expr = parseExpression();\n  expect(')');\n  return expr;\n} // 11.1 Primary Expressions\n\n\nconst legalKeywords = {\n  'if': 1\n};\n\nfunction parsePrimaryExpression() {\n  var type, token, expr;\n\n  if (match('(')) {\n    return parseGroupExpression();\n  }\n\n  if (match('[')) {\n    return parseArrayInitialiser();\n  }\n\n  if (match('{')) {\n    return parseObjectInitialiser();\n  }\n\n  type = lookahead.type;\n  index = lookahead.start;\n\n  if (type === TokenIdentifier || legalKeywords[lookahead.value]) {\n    expr = finishIdentifier(lex().value);\n  } else if (type === TokenStringLiteral || type === TokenNumericLiteral) {\n    if (lookahead.octal) {\n      throwError(lookahead, MessageStrictOctalLiteral);\n    }\n\n    expr = finishLiteral(lex());\n  } else if (type === TokenKeyword) {\n    throw new Error(DISABLED);\n  } else if (type === TokenBooleanLiteral) {\n    token = lex();\n    token.value = token.value === 'true';\n    expr = finishLiteral(token);\n  } else if (type === TokenNullLiteral) {\n    token = lex();\n    token.value = null;\n    expr = finishLiteral(token);\n  } else if (match('/') || match('/=')) {\n    expr = finishLiteral(scanRegExp());\n    peek();\n  } else {\n    throwUnexpected(lex());\n  }\n\n  return expr;\n} // 11.2 Left-Hand-Side Expressions\n\n\nfunction parseArguments() {\n  const args = [];\n  expect('(');\n\n  if (!match(')')) {\n    while (index < length) {\n      args.push(parseConditionalExpression());\n\n      if (match(')')) {\n        break;\n      }\n\n      expect(',');\n    }\n  }\n\n  expect(')');\n  return args;\n}\n\nfunction parseNonComputedProperty() {\n  index = lookahead.start;\n  const token = lex();\n\n  if (!isIdentifierName(token)) {\n    throwUnexpected(token);\n  }\n\n  return finishIdentifier(token.value);\n}\n\nfunction parseNonComputedMember() {\n  expect('.');\n  return parseNonComputedProperty();\n}\n\nfunction parseComputedMember() {\n  expect('[');\n  const expr = parseExpression();\n  expect(']');\n  return expr;\n}\n\nfunction parseLeftHandSideExpressionAllowCall() {\n  var expr, args, property;\n  expr = parsePrimaryExpression();\n\n  for (;;) {\n    if (match('.')) {\n      property = parseNonComputedMember();\n      expr = finishMemberExpression('.', expr, property);\n    } else if (match('(')) {\n      args = parseArguments();\n      expr = finishCallExpression(expr, args);\n    } else if (match('[')) {\n      property = parseComputedMember();\n      expr = finishMemberExpression('[', expr, property);\n    } else {\n      break;\n    }\n  }\n\n  return expr;\n} // 11.3 Postfix Expressions\n\n\nfunction parsePostfixExpression() {\n  const expr = parseLeftHandSideExpressionAllowCall();\n\n  if (lookahead.type === TokenPunctuator) {\n    if (match('++') || match('--')) {\n      throw new Error(DISABLED);\n    }\n  }\n\n  return expr;\n} // 11.4 Unary Operators\n\n\nfunction parseUnaryExpression() {\n  var token, expr;\n\n  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {\n    expr = parsePostfixExpression();\n  } else if (match('++') || match('--')) {\n    throw new Error(DISABLED);\n  } else if (match('+') || match('-') || match('~') || match('!')) {\n    token = lex();\n    expr = parseUnaryExpression();\n    expr = finishUnaryExpression(token.value, expr);\n  } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n    throw new Error(DISABLED);\n  } else {\n    expr = parsePostfixExpression();\n  }\n\n  return expr;\n}\n\nfunction binaryPrecedence(token) {\n  let prec = 0;\n\n  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {\n    return 0;\n  }\n\n  switch (token.value) {\n    case '||':\n      prec = 1;\n      break;\n\n    case '&&':\n      prec = 2;\n      break;\n\n    case '|':\n      prec = 3;\n      break;\n\n    case '^':\n      prec = 4;\n      break;\n\n    case '&':\n      prec = 5;\n      break;\n\n    case '==':\n    case '!=':\n    case '===':\n    case '!==':\n      prec = 6;\n      break;\n\n    case '<':\n    case '>':\n    case '<=':\n    case '>=':\n    case 'instanceof':\n    case 'in':\n      prec = 7;\n      break;\n\n    case '<<':\n    case '>>':\n    case '>>>':\n      prec = 8;\n      break;\n\n    case '+':\n    case '-':\n      prec = 9;\n      break;\n\n    case '*':\n    case '/':\n    case '%':\n      prec = 11;\n      break;\n  }\n\n  return prec;\n} // 11.5 Multiplicative Operators\n// 11.6 Additive Operators\n// 11.7 Bitwise Shift Operators\n// 11.8 Relational Operators\n// 11.9 Equality Operators\n// 11.10 Binary Bitwise Operators\n// 11.11 Binary Logical Operators\n\n\nfunction parseBinaryExpression() {\n  var marker, markers, expr, token, prec, stack, right, operator, left, i;\n  marker = lookahead;\n  left = parseUnaryExpression();\n  token = lookahead;\n  prec = binaryPrecedence(token);\n\n  if (prec === 0) {\n    return left;\n  }\n\n  token.prec = prec;\n  lex();\n  markers = [marker, lookahead];\n  right = parseUnaryExpression();\n  stack = [left, token, right];\n\n  while ((prec = binaryPrecedence(lookahead)) > 0) {\n    // Reduce: make a binary expression from the three topmost entries.\n    while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n      right = stack.pop();\n      operator = stack.pop().value;\n      left = stack.pop();\n      markers.pop();\n      expr = finishBinaryExpression(operator, left, right);\n      stack.push(expr);\n    } // Shift.\n\n\n    token = lex();\n    token.prec = prec;\n    stack.push(token);\n    markers.push(lookahead);\n    expr = parseUnaryExpression();\n    stack.push(expr);\n  } // Final reduce to clean-up the stack.\n\n\n  i = stack.length - 1;\n  expr = stack[i];\n  markers.pop();\n\n  while (i > 1) {\n    markers.pop();\n    expr = finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n    i -= 2;\n  }\n\n  return expr;\n} // 11.12 Conditional Operator\n\n\nfunction parseConditionalExpression() {\n  var expr, consequent, alternate;\n  expr = parseBinaryExpression();\n\n  if (match('?')) {\n    lex();\n    consequent = parseConditionalExpression();\n    expect(':');\n    alternate = parseConditionalExpression();\n    expr = finishConditionalExpression(expr, consequent, alternate);\n  }\n\n  return expr;\n} // 11.14 Comma Operator\n\n\nfunction parseExpression() {\n  const expr = parseConditionalExpression();\n\n  if (match(',')) {\n    throw new Error(DISABLED); // no sequence expressions\n  }\n\n  return expr;\n}\n\nfunction parser (code) {\n  source = code;\n  index = 0;\n  length = source.length;\n  lookahead = null;\n  peek();\n  const expr = parseExpression();\n\n  if (lookahead.type !== TokenEOF) {\n    throw new Error('Unexpect token after expression.');\n  }\n\n  return expr;\n}\n\nvar Constants = {\n  NaN: 'NaN',\n  E: 'Math.E',\n  LN2: 'Math.LN2',\n  LN10: 'Math.LN10',\n  LOG2E: 'Math.LOG2E',\n  LOG10E: 'Math.LOG10E',\n  PI: 'Math.PI',\n  SQRT1_2: 'Math.SQRT1_2',\n  SQRT2: 'Math.SQRT2',\n  MIN_VALUE: 'Number.MIN_VALUE',\n  MAX_VALUE: 'Number.MAX_VALUE'\n};\n\nfunction Functions (codegen) {\n  function fncall(name, args, cast, type) {\n    let obj = codegen(args[0]);\n\n    if (cast) {\n      obj = cast + '(' + obj + ')';\n      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';\n    }\n\n    return obj + '.' + name + (type < 0 ? '' : type === 0 ? '()' : '(' + args.slice(1).map(codegen).join(',') + ')');\n  }\n\n  function fn(name, cast, type) {\n    return args => fncall(name, args, cast, type);\n  }\n\n  const DATE = 'new Date',\n        STRING = 'String',\n        REGEXP = 'RegExp';\n  return {\n    // MATH functions\n    isNaN: 'Number.isNaN',\n    isFinite: 'Number.isFinite',\n    abs: 'Math.abs',\n    acos: 'Math.acos',\n    asin: 'Math.asin',\n    atan: 'Math.atan',\n    atan2: 'Math.atan2',\n    ceil: 'Math.ceil',\n    cos: 'Math.cos',\n    exp: 'Math.exp',\n    floor: 'Math.floor',\n    log: 'Math.log',\n    max: 'Math.max',\n    min: 'Math.min',\n    pow: 'Math.pow',\n    random: 'Math.random',\n    round: 'Math.round',\n    sin: 'Math.sin',\n    sqrt: 'Math.sqrt',\n    tan: 'Math.tan',\n    clamp: function (args) {\n      if (args.length < 3) error('Missing arguments to clamp function.');\n      if (args.length > 3) error('Too many arguments to clamp function.');\n      const a = args.map(codegen);\n      return 'Math.max(' + a[1] + ', Math.min(' + a[2] + ',' + a[0] + '))';\n    },\n    // DATE functions\n    now: 'Date.now',\n    utc: 'Date.UTC',\n    datetime: DATE,\n    date: fn('getDate', DATE, 0),\n    day: fn('getDay', DATE, 0),\n    year: fn('getFullYear', DATE, 0),\n    month: fn('getMonth', DATE, 0),\n    hours: fn('getHours', DATE, 0),\n    minutes: fn('getMinutes', DATE, 0),\n    seconds: fn('getSeconds', DATE, 0),\n    milliseconds: fn('getMilliseconds', DATE, 0),\n    time: fn('getTime', DATE, 0),\n    timezoneoffset: fn('getTimezoneOffset', DATE, 0),\n    utcdate: fn('getUTCDate', DATE, 0),\n    utcday: fn('getUTCDay', DATE, 0),\n    utcyear: fn('getUTCFullYear', DATE, 0),\n    utcmonth: fn('getUTCMonth', DATE, 0),\n    utchours: fn('getUTCHours', DATE, 0),\n    utcminutes: fn('getUTCMinutes', DATE, 0),\n    utcseconds: fn('getUTCSeconds', DATE, 0),\n    utcmilliseconds: fn('getUTCMilliseconds', DATE, 0),\n    // sequence functions\n    length: fn('length', null, -1),\n    join: fn('join', null),\n    indexof: fn('indexOf', null),\n    lastindexof: fn('lastIndexOf', null),\n    slice: fn('slice', null),\n    reverse: function (args) {\n      return '(' + codegen(args[0]) + ').slice().reverse()';\n    },\n    // STRING functions\n    parseFloat: 'parseFloat',\n    parseInt: 'parseInt',\n    upper: fn('toUpperCase', STRING, 0),\n    lower: fn('toLowerCase', STRING, 0),\n    substring: fn('substring', STRING),\n    split: fn('split', STRING),\n    replace: fn('replace', STRING),\n    trim: fn('trim', STRING, 0),\n    // REGEXP functions\n    regexp: REGEXP,\n    test: fn('test', REGEXP),\n    // Control Flow functions\n    if: function (args) {\n      if (args.length < 3) error('Missing arguments to if function.');\n      if (args.length > 3) error('Too many arguments to if function.');\n      const a = args.map(codegen);\n      return '(' + a[0] + '?' + a[1] + ':' + a[2] + ')';\n    }\n  };\n}\n\nfunction stripQuotes(s) {\n  const n = s && s.length - 1;\n  return n && (s[0] === '\"' && s[n] === '\"' || s[0] === '\\'' && s[n] === '\\'') ? s.slice(1, -1) : s;\n}\n\nfunction codegen (opt) {\n  opt = opt || {};\n  const allowed = opt.allowed ? toSet(opt.allowed) : {},\n        forbidden = opt.forbidden ? toSet(opt.forbidden) : {},\n        constants = opt.constants || Constants,\n        functions = (opt.functions || Functions)(visit),\n        globalvar = opt.globalvar,\n        fieldvar = opt.fieldvar,\n        outputGlobal = isFunction(globalvar) ? globalvar : id => \"\".concat(globalvar, \"[\\\"\").concat(id, \"\\\"]\");\n  let globals = {},\n      fields = {},\n      memberDepth = 0;\n\n  function visit(ast) {\n    if (isString(ast)) return ast;\n    const generator = Generators[ast.type];\n    if (generator == null) error('Unsupported type: ' + ast.type);\n    return generator(ast);\n  }\n\n  const Generators = {\n    Literal: n => n.raw,\n    Identifier: n => {\n      const id = n.name;\n\n      if (memberDepth > 0) {\n        return id;\n      } else if (hasOwnProperty(forbidden, id)) {\n        return error('Illegal identifier: ' + id);\n      } else if (hasOwnProperty(constants, id)) {\n        return constants[id];\n      } else if (hasOwnProperty(allowed, id)) {\n        return id;\n      } else {\n        globals[id] = 1;\n        return outputGlobal(id);\n      }\n    },\n    MemberExpression: n => {\n      const d = !n.computed,\n            o = visit(n.object);\n      if (d) memberDepth += 1;\n      const p = visit(n.property);\n\n      if (o === fieldvar) {\n        // strip quotes to sanitize field name (#1653)\n        fields[stripQuotes(p)] = 1;\n      }\n\n      if (d) memberDepth -= 1;\n      return o + (d ? '.' + p : '[' + p + ']');\n    },\n    CallExpression: n => {\n      if (n.callee.type !== 'Identifier') {\n        error('Illegal callee type: ' + n.callee.type);\n      }\n\n      const callee = n.callee.name,\n            args = n.arguments,\n            fn = hasOwnProperty(functions, callee) && functions[callee];\n      if (!fn) error('Unrecognized function: ' + callee);\n      return isFunction(fn) ? fn(args) : fn + '(' + args.map(visit).join(',') + ')';\n    },\n    ArrayExpression: n => '[' + n.elements.map(visit).join(',') + ']',\n    BinaryExpression: n => '(' + visit(n.left) + ' ' + n.operator + ' ' + visit(n.right) + ')',\n    UnaryExpression: n => '(' + n.operator + visit(n.argument) + ')',\n    ConditionalExpression: n => '(' + visit(n.test) + '?' + visit(n.consequent) + ':' + visit(n.alternate) + ')',\n    LogicalExpression: n => '(' + visit(n.left) + n.operator + visit(n.right) + ')',\n    ObjectExpression: n => '{' + n.properties.map(visit).join(',') + '}',\n    Property: n => {\n      memberDepth += 1;\n      const k = visit(n.key);\n      memberDepth -= 1;\n      return k + ':' + visit(n.value);\n    }\n  };\n\n  function codegen(ast) {\n    const result = {\n      code: visit(ast),\n      globals: Object.keys(globals),\n      fields: Object.keys(fields)\n    };\n    globals = {};\n    fields = {};\n    return result;\n  }\n\n  codegen.functions = functions;\n  codegen.constants = constants;\n  return codegen;\n}\n\nexport { ASTNode, ArrayExpression, BinaryExpression, CallExpression, ConditionalExpression, Identifier, Literal, LogicalExpression, MemberExpression, ObjectExpression, Property, RawCode, UnaryExpression, codegen, Constants as constants, Functions as functions, parser as parse };\n","exports.TYPES = {\n  QUANTITATIVE: 'quantitative',\n  ORDINAL: 'ordinal',\n  TEMPORAL: 'temporal',\n  NOMINAL: 'nominal',\n  GEOJSON: 'geojson'\n};\n\nexports.CHANNELS = [\"x\", \"y\", \"color\", \"shape\", \"size\", \"text\", \"row\", \"column\"];\nexports.OPS  = [\"equal\", \"lt\", \"lte\", \"gt\", \"gte\", \"range\", \"oneOf\", \"valid\"];\nexports.LOGIC_OPS = [\"and\", \"or\", \"not\"];","\"use strict\";\nexports.isArray = Array.isArray || function (obj) {\n  return {}.toString.call(obj) === '[object Array]';\n};\nfunction isString(item) {\n  return typeof item === 'string' || item instanceof String;\n}\nexports.isString = isString;\nfunction isin(item, array) {\n  return array.indexOf(item) !== -1;\n}\nexports.isin = isin;\n\nfunction json(s, sp) {\n  return JSON.stringify(s, null, sp);\n}\nexports.json = json;\n\nfunction keys(obj) {\n  var k = [], x;\n  for (x in obj) {\n    k.push(x);\n  }\n  return k;\n}\nexports.keys = keys;\n\nfunction duplicate(obj) {\n  if (obj === undefined) {\n    return undefined;\n  }\n  return JSON.parse(JSON.stringify(obj));\n}\nexports.duplicate = duplicate;\nexports.copy = duplicate;\n\nfunction forEach(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  }\n  else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k, obj);\n    }\n  }\n}\nexports.forEach = forEach;\n\nfunction any(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) {\n      return true;\n    }\n  }\n  return false;\n}\nexports.any = any;\n\nfunction nestedMap(collection, f, level, filter) {\n  return level === 0 ?\n    collection.map(f) :\n    collection.map(function (v) {\n      var r = nestedMap(v, f, level - 1);\n      return filter ? r.filter(nonEmpty) : r;\n    });\n}\nexports.nestedMap = nestedMap;\n\nfunction nestedReduce(collection, f, level, filter) {\n  return level === 0 ?\n    collection.reduce(f, []) :\n    collection.map(function (v) {\n      var r = nestedReduce(v, f, level - 1);\n      return filter ? r.filter(nonEmpty) : r;\n    });\n}\nexports.nestedReduce = nestedReduce;\n\nfunction nonEmpty(grp) {\n  return !exports.isArray(grp) || grp.length > 0;\n}\nexports.nonEmpty = nonEmpty;\n\nfunction traverse(node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  }\n  else {\n    if (node.left) {\n      traverse(node.left, arr);\n    }\n    if (node.right) {\n      traverse(node.right, arr);\n    }\n  }\n  return arr;\n}\nexports.traverse = traverse;\n\nfunction extend(obj, b) {\n  var rest = [];\n  for (var _i = 2; _i < arguments.length; _i++) {\n    rest[_i - 2] = arguments[_i];\n  }\n  for (var x, name, i = 1, len = arguments.length; i < len; ++i) {\n    x = arguments[i];\n    for (name in x) {\n      obj[name] = x[name];\n    }\n  }\n  return obj;\n}\nexports.extend = extend;\n\nfunction union(arr1, arr2, accessor = (d) => d) {\n  let result = [...arr1];\n  return result.concat(\n      arr2.filter(x => !arr1.find(y => accessor(x) === accessor(y)))\n    );\n}\nexports.union = union;\n\nvar gen;\n(function (gen) {\n  function getOpt(opt) {\n    return (opt ? keys(opt) : []).reduce(function (c, k) {\n      c[k] = opt[k];\n      return c;\n    }, Object.create({}));\n  }\n  gen.getOpt = getOpt;\n  ;\n})(gen = exports.gen || (exports.gen = {}));\nfunction powerset(list) {\n  var ps = [\n    []\n  ];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = ps.length; j < len; j++) {\n      ps.push(ps[j].concat(list[i]));\n    }\n  }\n  return ps;\n}\nexports.powerset = powerset;\n\nfunction chooseKorLess(list, k) {\n  var subset = [[]];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if (sub.length <= k) {\n        subset.push(sub);\n      }\n    }\n  }\n  return subset;\n}\nexports.chooseKorLess = chooseKorLess;\n\nfunction chooseK(list, k) {\n  var subset = [[]];\n  var kArray = [];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if (sub.length < k) {\n        subset.push(sub);\n      }\n      else if (sub.length === k) {\n        kArray.push(sub);\n      }\n    }\n  }\n  return kArray;\n}\nexports.chooseK = chooseK;\n\nfunction cross(a, b) {\n  var x = [];\n  for (var i = 0; i < a.length; i++) {\n    for (var j = 0; j < b.length; j++) {\n      x.push(a[i].concat(b[j]));\n    }\n  }\n  return x;\n}\nexports.cross = cross;\n\nfunction find(array, f, obj) {\n  for (var i = 0; i < array.length; i += 1) {\n    if (f(obj) === f(array[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\nexports.find = find;\nfunction rawEqual(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\nexports.rawEqual = rawEqual;\nfunction arrayDiff(a, b, f) {\n  return a.filter(function (x) {\n    if (!f) {\n      return b.findIndex(y => deepEqual(x,y)) < 0;\n    }\n    else\n      return find(b, f, x) < 0;\n  });\n}\nexports.arrayDiff = arrayDiff;\nfunction unionObjectArray(a, b, f) {\n  return arrayDiff(a, b, f).concat(b);\n}\nexports.unionObjectArray = unionObjectArray;\n\nfunction deepEqual(obj1, obj2) {\n  if (obj1 === obj2) {\n    return true;\n  }\n  if (isDate(obj1) && isDate(obj2)) {\n    return Number(obj1) === Number(obj2);\n  }\n  if (\n    typeof obj1 === \"object\" &&\n    obj1 !== undefined &&\n    typeof obj2 === \"object\" &&\n    obj2 !== undefined\n  ) {\n    const props1 = Object.keys(obj1);\n    const props2 = Object.keys(obj2);\n    if (props1.length !== props2.length) {\n      return false;\n    }\n\n    for (let i = 0; i < props1.length; i++) {\n      const prop = props1[i];\n\n      if (!Object.prototype.hasOwnProperty.call(obj2, prop) || !deepEqual(obj1[prop], obj2[prop])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\nexports.deepEqual = deepEqual;\n\n\nfunction isDate(o) {\n  return o !== undefined && typeof o.getMonth === \"function\";\n}\n\n// partitioning the array into N_p arrays\nfunction partition(arr, N_p) {\n  if (arr.length === N_p) {\n    return [arr.map(item => [item])]\n  } else if (N_p === 1) {\n    return [[arr]]\n  } else if (N_p > arr.length) {\n    throw new Error(`Cannot partition the array of ${arr.length} into ${N_p}.`);\n  } else if (arr.length === 0) {\n    return;\n  }\n  let item = [arr[0]];\n  let newArr = arr.slice(1);\n  let results =  partition(newArr, N_p - 1).map(pt => {\n    let newPt = duplicate(pt);\n    newPt.push(item)\n    return newPt\n  });\n  return partition(newArr, N_p).reduce((results, currPt) => {\n\n    return results.concat(currPt.map((p, i, currPt) => {\n      let newPt = duplicate(currPt);\n      let newP = duplicate(p);\n      newP.push(item[0]);\n      newPt[i] = newP;\n      return newPt;\n    }));\n  }, results)\n}\nexports.partition = partition;\n\nfunction permutate(arr) {\n  if (arr.length === 1) {\n    return [arr];\n  }\n  if (arr.length === 2) {\n    return [arr, [arr[1], arr[0]]];\n  }\n  return arr.reduce((acc, anchor, i) => {\n    const workingArr = duplicate(arr);\n    workingArr.splice(i, 1);\n\n    acc = acc.concat(\n      permutate(workingArr).map(newArr => {\n        return [anchor].concat(newArr);\n      })\n    );\n    return acc;\n  }, []);\n}\nexports.permutate = permutate;\n\nfunction intersection(arr1, arr2, accessor = (d) => d) {\n  return arr2.filter(x => arr1.filter(y => accessor(x) === accessor(y)).length > 0)\n}\nexports.intersection = intersection\n\nfunction unique(arr, accessor = (d) =>  d) {\n  let maps = arr.map(accessor).reduce((acc, curr) => {\n    acc[curr] = true;\n    return acc;\n  }, {});\n  return Object.keys(maps)\n}\nexports.unique = unique;\n//# sourceMappingURL=util.js.map","exports.DEFAULT_EDIT_OPS = {\n  \"markEditOps\":{\"AREA_BAR\":{\"name\":\"AREA_BAR\",\"cost\":0.03},\"AREA_LINE\":{\"name\":\"AREA_LINE\",\"cost\":0.02},\"AREA_POINT\":{\"name\":\"AREA_POINT\",\"cost\":0.04},\"AREA_TEXT\":{\"name\":\"AREA_TEXT\",\"cost\":0.08},\"AREA_TICK\":{\"name\":\"AREA_TICK\",\"cost\":0.04},\"BAR_LINE\":{\"name\":\"BAR_LINE\",\"cost\":0.04},\"BAR_POINT\":{\"name\":\"BAR_POINT\",\"cost\":0.02},\"BAR_TEXT\":{\"name\":\"BAR_TEXT\",\"cost\":0.06},\"BAR_TICK\":{\"name\":\"BAR_TICK\",\"cost\":0.02},\"LINE_POINT\":{\"name\":\"LINE_POINT\",\"cost\":0.03},\"LINE_TEXT\":{\"name\":\"LINE_TEXT\",\"cost\":0.07},\"LINE_TICK\":{\"name\":\"LINE_TICK\",\"cost\":0.03},\"POINT_TEXT\":{\"name\":\"POINT_TEXT\",\"cost\":0.05},\"POINT_TICK\":{\"name\":\"POINT_TICK\",\"cost\":0.01},\"TEXT_TICK\":{\"name\":\"TEXT_TICK\",\"cost\":0.05}},\n  \"transformEditOps\":{\"SCALE\":{\"name\":\"SCALE\",\"cost\":0.6},\"SORT\":{\"name\":\"SORT\",\"cost\":0.61},\"BIN\":{\"name\":\"BIN\",\"cost\":0.62},\"AGGREGATE\":{\"name\":\"AGGREGATE\",\"cost\":0.63},\"ADD_FILTER\":{\"name\":\"ADD_FILTER\",\"cost\":0.65},\"REMOVE_FILTER\":{\"name\":\"REMOVE_FILTER\",\"cost\":0.65},\"MODIFY_FILTER\":{\"name\":\"MODIFY_FILTER\",\"cost\":0.64}},\n  \"encodingEditOps\":{\"ADD_X\":{\"name\":\"ADD_X\",\"cost\":4.59},\"ADD_Y\":{\"name\":\"ADD_Y\",\"cost\":4.59},\"ADD_COLOR\":{\"name\":\"ADD_COLOR\",\"cost\":4.55},\"ADD_SHAPE\":{\"name\":\"ADD_SHAPE\",\"cost\":4.51},\"ADD_SIZE\":{\"name\":\"ADD_SIZE\",\"cost\":4.53},\"ADD_ROW\":{\"name\":\"ADD_ROW\",\"cost\":4.57},\"ADD_COLUMN\":{\"name\":\"ADD_COLUMN\",\"cost\":4.57},\"ADD_TEXT\":{\"name\":\"ADD_TEXT\",\"cost\":4.49},\"ADD_X_COUNT\":{\"name\":\"ADD_X_COUNT\",\"cost\":4.58},\"ADD_Y_COUNT\":{\"name\":\"ADD_Y_COUNT\",\"cost\":4.58},\"ADD_COLOR_COUNT\":{\"name\":\"ADD_COLOR_COUNT\",\"cost\":4.54},\"ADD_SHAPE_COUNT\":{\"name\":\"ADD_SHAPE_COUNT\",\"cost\":4.5},\"ADD_SIZE_COUNT\":{\"name\":\"ADD_SIZE_COUNT\",\"cost\":4.52},\"ADD_ROW_COUNT\":{\"name\":\"ADD_ROW_COUNT\",\"cost\":4.56},\"ADD_COLUMN_COUNT\":{\"name\":\"ADD_COLUMN_COUNT\",\"cost\":4.56},\"ADD_TEXT_COUNT\":{\"name\":\"ADD_TEXT_COUNT\",\"cost\":4.48},\"REMOVE_X_COUNT\":{\"name\":\"REMOVE_X_COUNT\",\"cost\":4.58},\"REMOVE_Y_COUNT\":{\"name\":\"REMOVE_Y_COUNT\",\"cost\":4.58},\"REMOVE_COLOR_COUNT\":{\"name\":\"REMOVE_COLOR_COUNT\",\"cost\":4.54},\"REMOVE_SHAPE_COUNT\":{\"name\":\"REMOVE_SHAPE_COUNT\",\"cost\":4.5},\"REMOVE_SIZE_COUNT\":{\"name\":\"REMOVE_SIZE_COUNT\",\"cost\":4.52},\"REMOVE_ROW_COUNT\":{\"name\":\"REMOVE_ROW_COUNT\",\"cost\":4.56},\"REMOVE_COLUMN_COUNT\":{\"name\":\"REMOVE_COLUMN_COUNT\",\"cost\":4.56},\"REMOVE_TEXT_COUNT\":{\"name\":\"REMOVE_TEXT_COUNT\",\"cost\":4.48},\"REMOVE_X\":{\"name\":\"REMOVE_X\",\"cost\":4.59},\"REMOVE_Y\":{\"name\":\"REMOVE_Y\",\"cost\":4.59},\"REMOVE_COLOR\":{\"name\":\"REMOVE_COLOR\",\"cost\":4.55},\"REMOVE_SHAPE\":{\"name\":\"REMOVE_SHAPE\",\"cost\":4.51},\"REMOVE_SIZE\":{\"name\":\"REMOVE_SIZE\",\"cost\":4.53},\"REMOVE_ROW\":{\"name\":\"REMOVE_ROW\",\"cost\":4.57},\"REMOVE_COLUMN\":{\"name\":\"REMOVE_COLUMN\",\"cost\":4.57},\"REMOVE_TEXT\":{\"name\":\"REMOVE_TEXT\",\"cost\":4.49},\"MODIFY_X\":{\"name\":\"MODIFY_X\",\"cost\":4.71},\"MODIFY_Y\":{\"name\":\"MODIFY_Y\",\"cost\":4.71},\"MODIFY_COLOR\":{\"name\":\"MODIFY_COLOR\",\"cost\":4.67},\"MODIFY_SHAPE\":{\"name\":\"MODIFY_SHAPE\",\"cost\":4.63},\"MODIFY_SIZE\":{\"name\":\"MODIFY_SIZE\",\"cost\":4.65},\"MODIFY_ROW\":{\"name\":\"MODIFY_ROW\",\"cost\":4.69},\"MODIFY_COLUMN\":{\"name\":\"MODIFY_COLUMN\",\"cost\":4.69},\"MODIFY_TEXT\":{\"name\":\"MODIFY_TEXT\",\"cost\":4.61},\"MODIFY_X_ADD_COUNT\":{\"name\":\"MODIFY_X_ADD_COUNT\",\"cost\":4.7},\"MODIFY_Y_ADD_COUNT\":{\"name\":\"MODIFY_Y_ADD_COUNT\",\"cost\":4.7},\"MODIFY_COLOR_ADD_COUNT\":{\"name\":\"MODIFY_COLOR_ADD_COUNT\",\"cost\":4.66},\"MODIFY_SHAPE_ADD_COUNT\":{\"name\":\"MODIFY_SHAPE_ADD_COUNT\",\"cost\":4.62},\"MODIFY_SIZE_ADD_COUNT\":{\"name\":\"MODIFY_SIZE_ADD_COUNT\",\"cost\":4.64},\"MODIFY_ROW_ADD_COUNT\":{\"name\":\"MODIFY_ROW_ADD_COUNT\",\"cost\":4.68},\"MODIFY_COLUMN_ADD_COUNT\":{\"name\":\"MODIFY_COLUMN_ADD_COUNT\",\"cost\":4.68},\"MODIFY_TEXT_ADD_COUNT\":{\"name\":\"MODIFY_TEXT_ADD_COUNT\",\"cost\":4.6},\"MODIFY_X_REMOVE_COUNT\":{\"name\":\"MODIFY_X_REMOVE_COUNT\",\"cost\":4.7},\"MODIFY_Y_REMOVE_COUNT\":{\"name\":\"MODIFY_Y_REMOVE_COUNT\",\"cost\":4.7},\"MODIFY_COLOR_REMOVE_COUNT\":{\"name\":\"MODIFY_COLOR_REMOVE_COUNT\",\"cost\":4.66},\"MODIFY_SHAPE_REMOVE_COUNT\":{\"name\":\"MODIFY_SHAPE_REMOVE_COUNT\",\"cost\":4.62},\"MODIFY_SIZE_REMOVE_COUNT\":{\"name\":\"MODIFY_SIZE_REMOVE_COUNT\",\"cost\":4.64},\"MODIFY_ROW_REMOVE_COUNT\":{\"name\":\"MODIFY_ROW_REMOVE_COUNT\",\"cost\":4.68},\"MODIFY_COLUMN_REMOVE_COUNT\":{\"name\":\"MODIFY_COLUMN_REMOVE_COUNT\",\"cost\":4.68},\"MODIFY_TEXT_REMOVE_COUNT\":{\"name\":\"MODIFY_TEXT_REMOVE_COUNT\",\"cost\":4.6},\"MOVE_X_ROW\":{\"name\":\"MOVE_X_ROW\",\"cost\":4.45},\"MOVE_X_COLUMN\":{\"name\":\"MOVE_X_COLUMN\",\"cost\":4.43},\"MOVE_X_SIZE\":{\"name\":\"MOVE_X_SIZE\",\"cost\":4.46},\"MOVE_X_SHAPE\":{\"name\":\"MOVE_X_SHAPE\",\"cost\":4.46},\"MOVE_X_COLOR\":{\"name\":\"MOVE_X_COLOR\",\"cost\":4.46},\"MOVE_X_Y\":{\"name\":\"MOVE_X_Y\",\"cost\":4.44},\"MOVE_X_TEXT\":{\"name\":\"MOVE_X_TEXT\",\"cost\":4.46},\"MOVE_Y_ROW\":{\"name\":\"MOVE_Y_ROW\",\"cost\":4.43},\"MOVE_Y_COLUMN\":{\"name\":\"MOVE_Y_COLUMN\",\"cost\":4.45},\"MOVE_Y_SIZE\":{\"name\":\"MOVE_Y_SIZE\",\"cost\":4.46},\"MOVE_Y_SHAPE\":{\"name\":\"MOVE_Y_SHAPE\",\"cost\":4.46},\"MOVE_Y_COLOR\":{\"name\":\"MOVE_Y_COLOR\",\"cost\":4.46},\"MOVE_Y_X\":{\"name\":\"MOVE_Y_X\",\"cost\":4.44},\"MOVE_Y_TEXT\":{\"name\":\"MOVE_Y_TEXT\",\"cost\":4.46},\"MOVE_COLOR_ROW\":{\"name\":\"MOVE_COLOR_ROW\",\"cost\":4.47},\"MOVE_COLOR_COLUMN\":{\"name\":\"MOVE_COLOR_COLUMN\",\"cost\":4.47},\"MOVE_COLOR_SIZE\":{\"name\":\"MOVE_COLOR_SIZE\",\"cost\":4.43},\"MOVE_COLOR_SHAPE\":{\"name\":\"MOVE_COLOR_SHAPE\",\"cost\":4.43},\"MOVE_COLOR_Y\":{\"name\":\"MOVE_COLOR_Y\",\"cost\":4.46},\"MOVE_COLOR_X\":{\"name\":\"MOVE_COLOR_X\",\"cost\":4.46},\"MOVE_COLOR_TEXT\":{\"name\":\"MOVE_COLOR_TEXT\",\"cost\":4.43},\"MOVE_SHAPE_ROW\":{\"name\":\"MOVE_SHAPE_ROW\",\"cost\":4.47},\"MOVE_SHAPE_COLUMN\":{\"name\":\"MOVE_SHAPE_COLUMN\",\"cost\":4.47},\"MOVE_SHAPE_SIZE\":{\"name\":\"MOVE_SHAPE_SIZE\",\"cost\":4.43},\"MOVE_SHAPE_COLOR\":{\"name\":\"MOVE_SHAPE_COLOR\",\"cost\":4.43},\"MOVE_SHAPE_Y\":{\"name\":\"MOVE_SHAPE_Y\",\"cost\":4.46},\"MOVE_SHAPE_X\":{\"name\":\"MOVE_SHAPE_X\",\"cost\":4.46},\"MOVE_SHAPE_TEXT\":{\"name\":\"MOVE_SHAPE_TEXT\",\"cost\":4.43},\"MOVE_SIZE_ROW\":{\"name\":\"MOVE_SIZE_ROW\",\"cost\":4.47},\"MOVE_SIZE_COLUMN\":{\"name\":\"MOVE_SIZE_COLUMN\",\"cost\":4.47},\"MOVE_SIZE_SHAPE\":{\"name\":\"MOVE_SIZE_SHAPE\",\"cost\":4.43},\"MOVE_SIZE_COLOR\":{\"name\":\"MOVE_SIZE_COLOR\",\"cost\":4.43},\"MOVE_SIZE_Y\":{\"name\":\"MOVE_SIZE_Y\",\"cost\":4.46},\"MOVE_SIZE_X\":{\"name\":\"MOVE_SIZE_X\",\"cost\":4.46},\"MOVE_SIZE_TEXT\":{\"name\":\"MOVE_SIZE_TEXT\",\"cost\":4.43},\"MOVE_TEXT_ROW\":{\"name\":\"MOVE_TEXT_ROW\",\"cost\":4.47},\"MOVE_TEXT_COLUMN\":{\"name\":\"MOVE_TEXT_COLUMN\",\"cost\":4.47},\"MOVE_TEXT_SHAPE\":{\"name\":\"MOVE_TEXT_SHAPE\",\"cost\":4.43},\"MOVE_TEXT_COLOR\":{\"name\":\"MOVE_TEXT_COLOR\",\"cost\":4.43},\"MOVE_TEXT_Y\":{\"name\":\"MOVE_TEXT_Y\",\"cost\":4.46},\"MOVE_TEXT_X\":{\"name\":\"MOVE_TEXT_X\",\"cost\":4.46},\"MOVE_TEXT_SIZE\":{\"name\":\"MOVE_TEXT_SIZE\",\"cost\":4.43},\"MOVE_COLUMN_ROW\":{\"name\":\"MOVE_COLUMN_ROW\",\"cost\":4.44},\"MOVE_COLUMN_SIZE\":{\"name\":\"MOVE_COLUMN_SIZE\",\"cost\":4.47},\"MOVE_COLUMN_SHAPE\":{\"name\":\"MOVE_COLUMN_SHAPE\",\"cost\":4.47},\"MOVE_COLUMN_COLOR\":{\"name\":\"MOVE_COLUMN_COLOR\",\"cost\":4.47},\"MOVE_COLUMN_Y\":{\"name\":\"MOVE_COLUMN_Y\",\"cost\":4.45},\"MOVE_COLUMN_X\":{\"name\":\"MOVE_COLUMN_X\",\"cost\":4.43},\"MOVE_COLUMN_TEXT\":{\"name\":\"MOVE_COLUMN_TEXT\",\"cost\":4.47},\"MOVE_ROW_COLUMN\":{\"name\":\"MOVE_ROW_COLUMN\",\"cost\":4.44},\"MOVE_ROW_SIZE\":{\"name\":\"MOVE_ROW_SIZE\",\"cost\":4.47},\"MOVE_ROW_SHAPE\":{\"name\":\"MOVE_ROW_SHAPE\",\"cost\":4.47},\"MOVE_ROW_COLOR\":{\"name\":\"MOVE_ROW_COLOR\",\"cost\":4.47},\"MOVE_ROW_Y\":{\"name\":\"MOVE_ROW_Y\",\"cost\":4.43},\"MOVE_ROW_X\":{\"name\":\"MOVE_ROW_X\",\"cost\":4.45},\"MOVE_ROW_TEXT\":{\"name\":\"MOVE_ROW_TEXT\",\"cost\":4.47},\"SWAP_X_Y\":{\"name\":\"SWAP_X_Y\",\"cost\":4.42},\"SWAP_ROW_COLUMN\":{\"name\":\"SWAP_ROW_COLUMN\",\"cost\":4.41},\"ceiling\":{\"cost\":47.1,\"alternatingCost\":51.81}}\n}","\"use strict\";\nvar util = require('../util');\nvar def = require('../editOp/editOpSet');\nfunction neighbors(spec, additionalFields, additionalChannels, importedEncodingEditOps) {\n  var neighbors = [];\n  var encodingEditOps = importedEncodingEditOps || def.DEFAULT_ENCODING_EDIT_OPS;\n  var inChannels = util.keys(spec.encoding);\n  var exChannels = additionalChannels;\n\n  inChannels.forEach(function (channel) {\n    var newNeighbor = util.duplicate(spec);\n    var editOpType = \"REMOVE_\" + channel.toUpperCase();\n    editOpType += (spec.encoding[channel].field === \"*\") ? \"_COUNT\" : \"\";\n    var editOp = util.duplicate(encodingEditOps[editOpType]);\n    var newAdditionalFields = util.duplicate(additionalFields);\n    if (util.find(newAdditionalFields, util.rawEqual, newNeighbor.encoding[channel]) === -1) {\n      newAdditionalFields.push(newNeighbor.encoding[channel]);\n    }\n    var newAdditionalChannels = util.duplicate(additionalChannels);\n    editOp.detail = {\n      \"before\": {\"field\": newNeighbor.encoding[channel].field, channel},\n      \"after\": undefined\n    };\n\n    newAdditionalChannels.push(channel);\n    delete newNeighbor.encoding[channel];\n    if (validate(newNeighbor)) {\n      newNeighbor.editOp = editOp;\n      newNeighbor.additionalFields = newAdditionalFields;\n      newNeighbor.additionalChannels = newAdditionalChannels;\n      neighbors.push(newNeighbor);\n    }\n    ;\n    additionalFields.forEach(function (field, index) {\n      if ((field.field !== spec.encoding[channel].field) ||\n        (field.type !== spec.encoding[channel].type)) {\n        newNeighbor = util.duplicate(spec);\n        editOpType = \"MODIFY_\" + channel.toUpperCase();\n        if (spec.encoding[channel].field === \"*\" && field.field !== \"*\") {\n          editOpType += \"_REMOVE_COUNT\";\n        }\n        else if (spec.encoding[channel].field !== \"*\" && field.field === \"*\") {\n          editOpType += \"_ADD_COUNT\";\n        }\n        editOp = util.duplicate(encodingEditOps[editOpType]);\n        newAdditionalFields = util.duplicate(additionalFields);\n        newAdditionalFields.splice(index, 1);\n        if (util.find(newAdditionalFields, util.rawEqual, newNeighbor.encoding[channel]) === -1) {\n          newAdditionalFields.push(newNeighbor.encoding[channel]);\n        }\n        newAdditionalChannels = util.duplicate(additionalChannels);\n        newNeighbor.encoding[channel] = field;\n        editOp.detail = {\n          \"before\": { ...spec.encoding[channel], channel},\n          \"after\": { ...field, channel}\n        };\n\n        if (validate(newNeighbor)) {\n          newNeighbor.editOp = editOp;\n          newNeighbor.additionalFields = newAdditionalFields;\n          newNeighbor.additionalChannels = newAdditionalChannels;\n          neighbors.push(newNeighbor);\n        }\n        ;\n      }\n    });\n    inChannels.forEach(function (anotherChannel) {\n      if (anotherChannel === channel\n        || ([\"x\", \"y\"].indexOf(channel) < 0 || [\"x\", \"y\"].indexOf(anotherChannel) < 0)) {\n        return;\n      }\n      newNeighbor = util.duplicate(spec);\n      editOp = util.duplicate(encodingEditOps[\"SWAP_X_Y\"]);\n      newAdditionalFields = util.duplicate(additionalFields);\n      newAdditionalChannels = util.duplicate(additionalChannels);\n      var tempChannel = util.duplicate(newNeighbor.encoding[channel]);\n      newNeighbor.encoding[channel] = newNeighbor.encoding[anotherChannel];\n      newNeighbor.encoding[anotherChannel] = tempChannel;\n      editOp.detail = {\n        \"before\": {\"field\": spec.encoding[\"x\"].field, \"channel\": \"x\"},\n        \"after\": {\"field\": spec.encoding[\"y\"].field, \"channel\": \"y\"}\n      };\n\n      if (validate(newNeighbor)) {\n        newNeighbor.editOp = editOp;\n        newNeighbor.additionalFields = newAdditionalFields;\n        newNeighbor.additionalChannels = newAdditionalChannels;\n        neighbors.push(newNeighbor);\n      };\n    });\n    exChannels.forEach(function (exChannel, index) {\n      newNeighbor = util.duplicate(spec);\n      var newNeighborChannels = (channel + \"_\" + exChannel).toUpperCase();\n      editOp = util.duplicate(encodingEditOps[\"MOVE_\" + newNeighborChannels]);\n      newAdditionalFields = util.duplicate(additionalFields);\n      newAdditionalChannels = util.duplicate(additionalChannels);\n      newAdditionalChannels.splice(index, 1);\n      newAdditionalChannels.push(channel);\n      newNeighbor.encoding[exChannel] = util.duplicate(newNeighbor.encoding[channel]);\n      delete newNeighbor.encoding[channel];\n      editOp.detail = {\n        \"before\": {channel},\n        \"after\": {\"channel\": exChannel}\n      };\n\n      if (validate(newNeighbor)) {\n        newNeighbor.editOp = editOp;\n        newNeighbor.additionalFields = newAdditionalFields;\n        newNeighbor.additionalChannels = newAdditionalChannels;\n        neighbors.push(newNeighbor);\n      }\n      ;\n    });\n  });\n  exChannels.forEach(function (channel, chIndex) {\n    additionalFields.forEach(function (field, index) {\n      var newNeighbor = util.duplicate(spec);\n      var editOpType = \"ADD_\" + channel.toUpperCase();\n      editOpType += (field.field === \"*\") ? \"_COUNT\" : \"\";\n      var editOp = util.duplicate(encodingEditOps[editOpType]);\n      var newAdditionalFields = util.duplicate(additionalFields);\n      var newAdditionalChannels = util.duplicate(additionalChannels);\n      newAdditionalFields.splice(index, 1);\n      newNeighbor.encoding[channel] = field;\n      newAdditionalChannels.splice(chIndex, 1);\n\n      editOp.detail = {\n        \"before\": undefined,\n        \"after\": {\"field\": field.field, channel}\n      };\n\n      if (validate(newNeighbor)) {\n        newNeighbor.editOp = editOp;\n        newNeighbor.additionalFields = newAdditionalFields;\n        newNeighbor.additionalChannels = newAdditionalChannels;\n        neighbors.push(newNeighbor);\n      }\n      ;\n    });\n  });\n  for (var i = 0; i < neighbors.length; i += 1) {\n    for (var j = i + 1; j < neighbors.length; j += 1) {\n      if (sameEncoding(neighbors[i].encoding, neighbors[j].encoding)) {\n        neighbors.splice(j, 1);\n        j -= 1;\n      }\n    }\n  }\n  return neighbors;\n}\nexports.neighbors = neighbors;\nfunction validate(spec) {\n  return true;\n}\nfunction sameEncoding(a, b) {\n  var aKeys = util.keys(a);\n  var bKeys = util.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n  var allKeys = util.union(aKeys, bKeys);\n  for (var i = 0; i < allKeys.length; i += 1) {\n    var key = allKeys[i];\n    if (!(a[key] && b[key])) {\n      return false;\n    }\n    if ((a[key].field !== b[key].field) || a[key].type !== b[key].type) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.sameEncoding = sameEncoding;","\nconst d3 = require(\"d3\");\nconst vega = require(\"vega\");\nconst vl = require(\"vega-lite\");\nvar expr = require('vega-expression');\nconst { TYPES, CHANNELS, OPS, LOGIC_OPS } = require('../constants');\nvar util = require('../util');\nconst DEFAULT_EDIT_OPS = require('../editOp/editOpSet').DEFAULT_EDIT_OPS;\nvar nb = require('./neighbor');\n\n\nasync function transition(s, d, importedTransitionCosts, transOptions) {\n  var importedMarkEditOps = importedTransitionCosts ? importedTransitionCosts.markEditOps : DEFAULT_EDIT_OPS[\"markEditOps\"];\n  var importedTransformEditOps = importedTransitionCosts ? importedTransitionCosts.transformEditOps : DEFAULT_EDIT_OPS[\"transformEditOps\"];\n  var importedEncodingEditOps = importedTransitionCosts ? importedTransitionCosts.encodingEditOps : DEFAULT_EDIT_OPS[\"encodingEditOps\"];\n  let _transformEditOps = await transformEditOps(s, d, importedTransformEditOps, transOptions);\n  var trans = {\n    mark: markEditOps(s, d, importedMarkEditOps).map(eo => { return {...eo, type: \"mark\"}}),\n    transform: _transformEditOps.map(eo => { return {...eo, type: \"transform\"}}),\n    encoding: encodingEditOps(s, d, importedEncodingEditOps).map(eo => { return {...eo, type: \"encoding\"}})\n  };\n\n  //Todo: if there is a MOVE_A_B and the field has Transform, ignore the transform\n  const re = new RegExp(\"^MOVE_\")\n  trans.transform = trans.transform.filter(editOp => {\n    if (editOp.name.indexOf(\"FILTER\") >= 0) {\n      return true;\n    }\n    let moveEditOps = trans.encoding.filter(eo => re.test(eo.name) );\n    if (moveEditOps.length ===0) {\n      return true;\n    }\n    moveEditOps.forEach(moveEditOp => {\n\n      let sChannel = moveEditOp.detail.before.channel,\n        dChannel = moveEditOp.detail.after.channel;\n      let removed = editOp.detail.findIndex(dt => (dt.how === \"removed\") && (dt.channel === sChannel))\n      let added = editOp.detail.findIndex(dt => (dt.how === \"added\") && (dt.channel === dChannel))\n      if ((removed >= 0) && (added >= 0)) {\n        editOp.detail = editOp.detail.filter((dt, i) => [removed, added].indexOf(i)<0);\n      }\n    })\n    return editOp.detail.length > 0\n  })\n\n\n\n  var cost = 0;\n\n  cost = trans.encoding.reduce(function (prev, editOp) {\n    if (editOp.name.indexOf('_COUNT') >= 0) {\n      var channel = editOp.name.replace(/COUNT/g, '').replace(/ADD/g, '').replace(/REMOVE/g, '').replace(/MODIFY/g, '').replace(/_/g, '').toLowerCase();\n      var aggEditOp = trans.transform.filter(function (editOp) { return editOp.name === \"AGGREGATE\"; })[0];\n      if (aggEditOp\n          && aggEditOp.detail.length === 1\n          && aggEditOp.detail.filter(function (dt) { return dt.channel.toLowerCase() === channel; }).length) {\n        aggEditOp.cost = 0;\n      }\n      var binEditOp = trans.transform.filter(function (editOp) { return editOp.name === \"BIN\"; })[0];\n      if (binEditOp && binEditOp.detail.filter(function (dt) {\n        if (dt.how === \"added\") {\n          return d.encoding[dt.channel].type === TYPES.QUANTITATIVE;\n        }\n        else {\n          return s.encoding[dt.channel].type === TYPES.QUANTITATIVE;\n        }\n      }).length > 0) {\n        binEditOp.cost = 0;\n      }\n    }\n    prev += editOp.cost;\n    return prev;\n  }, cost);\n  cost = trans.mark.reduce(function (prev, editOp) {\n    prev += editOp.cost;\n    return prev;\n  }, cost);\n  cost = trans.transform.reduce(function (prev, editOp) {\n    prev += editOp.cost;\n    return prev;\n  }, cost);\n\n  return {\n    ...trans,\n    cost\n  };\n}\nexports.transition = transition;\nfunction markEditOps(s, d, importedMarkEditOps) {\n  var editOps = [];\n  var markEditOps = importedMarkEditOps || DEFAULT_EDIT_OPS[\"markEditOps\"];\n  var newEditOp;\n  const sMarkType = typeof(s.mark) === \"object\" ? s.mark.type : s.mark;\n  const dMarkType = typeof(d.mark) === \"object\" ? d.mark.type : d.mark;\n  if (!sMarkType || !dMarkType || (sMarkType === dMarkType) || sMarkType === \"null\" || dMarkType === \"null\") {\n    return editOps;\n  } else {\n    var editOpName = [sMarkType.toUpperCase(), dMarkType.toUpperCase()].sort().join(\"_\");\n    if (markEditOps[editOpName]) {\n      newEditOp = util.duplicate(markEditOps[editOpName]);\n      newEditOp.detail = { \"before\": sMarkType, \"after\": dMarkType };\n      editOps.push(newEditOp);\n    } else {\n      console.error(`Cannot find ${editOpName} marktype change edit op.`)\n    }\n  }\n  return editOps;\n}\nexports.markEditOps = markEditOps;\n\nasync function transformEditOps(s, d, importedTransformEditOps, transOptions) {\n  const TRANSFORM_TYPES = [\"SCALE\", \"SORT\", \"AGGREGATE\", \"BIN\", \"SETTYPE\"];\n  var transformEditOps = importedTransformEditOps || DEFAULT_EDIT_OPS[\"transformEditOps\"];\n  var editOps = [];\n\n  for (let i = 0; i < CHANNELS.length; i++) {\n    const channel = CHANNELS[i];\n\n    for (let j = 0; j < TRANSFORM_TYPES.length; j++) {\n      const transformType = TRANSFORM_TYPES[j];\n      let editOp;\n\n      if (transformType === \"SETTYPE\" && transformEditOps[transformType]) {\n        editOp = transformSettype(s, d, channel, transformEditOps);\n      } else if (transformType === \"SCALE\" && transformEditOps[transformType]) {\n        editOp = await scaleEditOps(s, d, channel, transformEditOps[transformType], transOptions);\n      } else if (transformEditOps[transformType]) {\n        editOp = transformBasic(s, d, channel, transformType, transformEditOps);\n      }\n\n      if (editOp) {\n        let found = editOps.find(eo => eo.name === editOp.name);\n        if (found) {\n          found.detail.push(editOp.detail);\n        } else {\n          editOp.detail = [editOp.detail];\n          editOps.push(editOp);\n\n        }\n      }\n    };\n\n  };\n\n  var importedFilterEditOps = {\n    \"MODIFY_FILTER\": transformEditOps[\"MODIFY_FILTER\"],\n    \"ADD_FILTER\": transformEditOps[\"ADD_FILTER\"],\n    \"REMOVE_FILTER\": transformEditOps[\"REMOVE_FILTER\"]\n  };\n\n  editOps = editOps.concat(filterEditOps(s, d, importedFilterEditOps));\n\n  return editOps;\n}\nexports.transformEditOps = transformEditOps;\nfunction transformBasic(s, d, channel, transform, transformEditOps) {\n  var sHas = false;\n  var dHas = false;\n  var editOp;\n  var sEditOp, dEditOp;\n  if (s.encoding[channel] && s.encoding[channel][transform.toLowerCase()]) {\n    sHas = true;\n    sEditOp = s.encoding[channel][transform.toLowerCase()];\n  }\n  if (d.encoding[channel] && d.encoding[channel][transform.toLowerCase()]) {\n    dHas = true;\n    dEditOp = d.encoding[channel][transform.toLowerCase()];\n  }\n\n  if (sHas && dHas && (!util.rawEqual(sEditOp, dEditOp))) {\n    editOp = util.duplicate(transformEditOps[transform]);\n    editOp.detail = { how: \"modified\", channel: channel };\n    return editOp;\n  }\n  else if (sHas && !dHas) {\n    editOp = util.duplicate(transformEditOps[transform]);\n    editOp.detail = { how: \"removed\", channel: channel };\n    return editOp;\n  }\n  else if (!sHas && dHas) {\n    editOp = util.duplicate(transformEditOps[transform]);\n    editOp.detail = { how: \"added\", channel: channel };\n    return editOp;\n  }\n}\nexports.transformBasic = transformBasic;\n\nasync function scaleEditOps(s, d, channel, scaleTransformEditOps, transOptions) {\n  var sHas = false, sOnlyHasDomainRelated = false;\n  var dHas = false, dOnlyHasDomainRelated = false;\n  var editOp, sScaleDef, dScaleDef;\n\n  if (s.encoding[channel] && s.encoding[channel].scale) {\n    sHas = true;\n    sScaleDef = {...s.encoding[channel].scale};\n    if (!Object.keys(sScaleDef).find(key => [\"domain\", \"zero\"].indexOf(key) < 0) ) {\n      sOnlyHasDomainRelated = true;\n    }\n  }\n  if (d.encoding[channel] && d.encoding[channel].scale) {\n    dHas = true;\n    dScaleDef = {...d.encoding[channel].scale};\n    if (!Object.keys(dScaleDef).find(key => [\"domain\", \"zero\"].indexOf(key) < 0) ) {\n      dOnlyHasDomainRelated = true;\n    }\n  }\n  if (transOptions && transOptions.omitIncludeRawDomain) {\n    if (sScaleDef && sScaleDef.domain && dScaleDef.domain === \"unaggregated\") {\n      delete sScaleDef.domain;\n      if (Object.keys(sScaleDef).length === 0) {\n        sOnlyHasDomainRelated = false;\n        sHas = false;\n      }\n    }\n\n    if (dScaleDef && dScaleDef.domain && (dScaleDef.domain === \"unaggregated\")) {\n      delete dScaleDef.domain;\n      if (Object.keys(dScaleDef).length === 0) {\n        dOnlyHasDomainRelated = false;\n        dHas = false;\n      }\n    }\n  }\n\n  if (sHas && dHas && (!util.rawEqual(sScaleDef, dScaleDef))) {\n    if (sOnlyHasDomainRelated && dOnlyHasDomainRelated && await sameDomain(s,d, channel)) {\n      return;\n    }\n    editOp = util.duplicate(scaleTransformEditOps);\n    editOp.detail = {\n      how: \"modified\",\n      channel: channel,\n      fieldType: {\n        from: s.encoding[channel].type,\n        to: d.encoding[channel].type\n      }\n    };\n    return editOp;\n  }\n  else if (sHas && !dHas) {\n\n    if (sOnlyHasDomainRelated && await sameDomain(s,d, channel)) {\n      return;\n    }\n\n    editOp = util.duplicate(scaleTransformEditOps);\n    editOp.detail = { how: \"removed\", channel: channel, fieldType: s.encoding[channel].type };\n    return editOp;\n  }\n  else if (!sHas && dHas) {\n    if (dOnlyHasDomainRelated && await sameDomain(s,d, channel)) {\n      return;\n    }\n    editOp = util.duplicate(scaleTransformEditOps);\n    editOp.detail = { how: \"added\", channel: channel, fieldType: d.encoding[channel].type };\n    return editOp;\n  }\n}\nexports.scaleEditOps = scaleEditOps;\nasync function sameDomain(s, d, channel) {\n\n  let dView, sView;\n  try {\n    dView = await new vega.View(vega.parse(vl.compile(util.duplicate(d)).spec), {\n      renderer: \"svg\"\n    }).runAsync();\n\n    sView = await new vega.View(vega.parse(vl.compile(util.duplicate(s)).spec), {\n      renderer: \"svg\"\n    }).runAsync();\n  } catch (e) {\n    return false;\n  }\n\n\n  const sScale = sView._runtime.scales[channel].value;\n  const dScale = dView._runtime.scales[channel].value;\n\n\n  return util.deepEqual(sScale.domain(), dScale.domain())\n}\nexports.sameDomain = sameDomain;\n\nfunction filterEditOps(s, d, importedFilterEditOps) {\n\n  var sFilters = [], dFilters = [];\n  var editOps = [];\n\n  if (s.transform) {\n\n    sFilters = getFilters(s.transform.filter(trsfm => trsfm.filter).map(trsfm => trsfm.filter));\n  }\n  if (d.transform) {\n    dFilters = getFilters(d.transform.filter(trsfm => trsfm.filter).map(trsfm => trsfm.filter));\n  }\n\n  if (sFilters.length === 0 && dFilters.length === 0) {\n    return editOps;\n  }\n\n  var dOnly = util.arrayDiff(dFilters, sFilters);\n  var sOnly = util.arrayDiff(sFilters, dFilters);\n\n  var isFind = false;\n  for (var i = 0; i < dOnly.length; i++) {\n    for (var j = 0; j < sOnly.length; j++) {\n      if (dOnly[i].id === sOnly[j].id) {\n        var newEditOp = util.duplicate(importedFilterEditOps[\"MODIFY_FILTER\"]);\n        newEditOp.detail = {\n          \"what\": [], \"id\": sOnly[j].id, \"before\":[], \"after\":[],\n          \"sFilter\": sOnly[j],\n          \"eFilter\": dOnly[i]\n        };\n        if (!util.deepEqual(sOnly[j].op, dOnly[i].op)) {\n          newEditOp.detail.what.push(\"op\")\n          newEditOp.detail.before.push(sOnly[j].op);\n          newEditOp.detail.after.push(dOnly[i].op);\n        }\n        if (!util.deepEqual(sOnly[j].value, dOnly[i].value)) {\n          newEditOp.detail.what.push(\"value\")\n          newEditOp.detail.before.push(sOnly[j].value);\n          newEditOp.detail.after.push(dOnly[i].value);\n        }\n        editOps.push(newEditOp);\n        dOnly.splice(i, 1);\n        sOnly.splice(j, 1);\n        isFind = true;\n        break;\n      }\n    }\n    if (isFind) {\n      isFind = false;\n      i--;\n      continue;\n    }\n  }\n  for (var i = 0; i < dOnly.length; i++) {\n    var newEditOp = util.duplicate(importedFilterEditOps[\"ADD_FILTER\"]);\n    newEditOp.detail = newEditOp.detail = {\n      \"id\": dOnly[i].id,\n      \"what\": [\"field\", \"op\", \"value\"],\n      \"before\":[undefined, undefined, undefined],\n      \"after\":[dOnly[i].field, dOnly[i].op, dOnly[i].value],\n      \"eFilter\": dOnly[i],\n      \"sFilter\": undefined,\n    };\n\n    editOps.push(newEditOp);\n  }\n  for (var i = 0; i < sOnly.length; i++) {\n    var newEditOp = util.duplicate(importedFilterEditOps[\"REMOVE_FILTER\"]);\n    newEditOp.detail = newEditOp.detail = {\n      \"id\": sOnly[i].id,\n      \"what\": [\"field\", \"op\", \"value\"],\n      \"before\": [sOnly[i].field, sOnly[i].op, sOnly[i].value],\n      \"after\": [undefined, undefined, undefined],\n      \"sFilter\": sOnly[i],\n      \"eFilter\": undefined,\n    };\n\n    editOps.push(newEditOp);\n  }\n  return editOps;\n}\nexports.filterEditOps = filterEditOps;\n\nfunction getFilters (filterExpression) {\n  let filters;\n  if (util.isArray(filterExpression)) {\n    filters = filterExpression.reduce((acc, expression) => {\n      return acc.concat(parsePredicateFilter(expression));\n    }, []);\n  } else {\n    filters = parsePredicateFilter(filterExpression);\n  }\n\n  filters = d3.groups(filters, filter => filter.id)\n    .map(group => {\n      return {\n        id: group[0],\n        field: group[1].map(filter => filter.field),\n        op: group[1].map(filter => filter.op),\n        value: group[1].map(filter => filter.value)\n      }\n    })\n\n  return filters;\n\n\n}\nexports.getFilters = getFilters;\n\nfunction parsePredicateFilter(expression) {\n\n  let parsed = [];\n  if (util.isString(expression)) {\n    parsed = parsed.concat(stringFilter(expression));\n  } else {\n    LOGIC_OPS.filter(logicOp => expression.hasOwnProperty(logicOp)).forEach(logicOp => {\n      let subParsed;\n      if (util.isArray(expression[logicOp])) {\n        subParsed = expression[logicOp].reduce((subParsed, expr) => {\n          return subParsed.concat(parsePredicateFilter(expr))\n        }, []);\n      } else {\n        subParsed = parsePredicateFilter(expression[logicOp]);\n      }\n      let id = subParsed.map(f => f.id).join(\"_\")\n      parsed.push({\n        \"id\": `${logicOp}>[${id}]`,\n        \"op\": logicOp,\n        \"value\": subParsed\n      })\n    })\n\n    OPS.filter(op => expression.hasOwnProperty(op))\n      .forEach(op => {\n      parsed.push({\n        \"id\": expression.field,\n        \"field\": expression.field,\n        \"op\": op,\n        \"value\": JSON.stringify(expression[op])\n      });\n    })\n  }\n\n  if (parsed.length === 0) {\n    console.log(\"WARN: cannot parse filters.\");\n  }\n  return parsed;\n}\nexports.parsePredicateFilter = parsePredicateFilter;\n\nfunction stringFilter(expression) {\n  var parser = expr[\"parse\"];\n  var expressionTree = parser(expression);\n\n  return binaryExprsFromExprTree(expressionTree, [], 0).map(function (bExpr) {\n    return {\n      \"id\": bExpr.left.property.name,\n      \"field\": bExpr.left.property.name,\n      \"op\": bExpr.operator,\n      \"value\": bExpr.right.raw\n    };\n  });\n\n  function binaryExprsFromExprTree(tree, arr, depth) {\n    if (tree.operator === '||' || tree.operator === '&&') {\n      arr = binaryExprsFromExprTree(tree.left, arr, depth + 1);\n      arr = binaryExprsFromExprTree(tree.right, arr, depth + 1);\n    }\n    else if (['==', '===', '!==', '!=', '<', '<=', '>', '>='].indexOf(tree.operator) >= 0) {\n      tree.depth = depth;\n      arr.push(tree);\n    }\n    return arr;\n  }\n}\n\n\n\nfunction transformSettype(s, d, channel, transformEditOps) {\n  var editOp;\n  if (s.encoding[channel] && d.encoding[channel]\n    && (d.encoding[channel][\"field\"] === s.encoding[channel][\"field\"])\n    && (d.encoding[channel][\"type\"] !== s.encoding[channel][\"type\"])) {\n    editOp = util.duplicate(transformEditOps[\"SETTYPE\"]);\n    editOp.detail = {\n      \"before\": s.encoding[channel][\"type\"],\n      \"after\": d.encoding[channel][\"type\"],\n      channel: channel\n    };\n    return editOp;\n  }\n}\nexports.transformSettype = transformSettype;\n\n\nfunction encodingEditOps(s, d, importedEncodingEditOps) {\n  if (nb.sameEncoding(s.encoding, d.encoding)) {\n    return [];\n  }\n  var sChannels = util.keys(s.encoding);\n  var sFields = sChannels.map(function (key) {\n    return s.encoding[key];\n  });\n  var dChannels = util.keys(d.encoding);\n  var dFields = dChannels.map(function (key) {\n    return d.encoding[key];\n  });\n  var additionalFields = util.union(dFields, sFields, function (field) { return field.field + \"_\" + field.type; });\n  var additionalChannels = util.arrayDiff(dChannels, sChannels);\n  var u;\n  function nearestNode(nodes) {\n    var minD = Infinity;\n    var argMinD = -1;\n    nodes.forEach(function (node, index) {\n      if (node.distance < minD) {\n        minD = node.distance;\n        argMinD = index;\n      }\n    });\n    return nodes.splice(argMinD, 1)[0];\n  }\n  var nodes = nb.neighbors(s, additionalFields, additionalChannels, importedEncodingEditOps)\n    .map(function (neighbor) {\n    neighbor.distance = neighbor.editOp.cost,\n      neighbor.prev = [s];\n    return neighbor;\n  });\n  s.distance = 0;\n  s.prev = [];\n  var doneNodes = [s];\n  while (nodes.length > 0) {\n    u = nearestNode(nodes);\n    if (nb.sameEncoding(u.encoding, d.encoding)) {\n      break;\n    }\n    if (u.distance >= importedEncodingEditOps.ceiling.cost) {\n      return [{ name: 'OVER_THE_CEILING', cost: importedEncodingEditOps.ceiling.alternatingCost }];\n    }\n    var newNodes = nb.neighbors(u, additionalFields, u.additionalChannels, importedEncodingEditOps);\n    newNodes.forEach(function (newNode) {\n      var node;\n      for (var i = 0; i < doneNodes.length; i += 1) {\n        if (nb.sameEncoding(doneNodes[i].encoding, newNode.encoding)) {\n          return;\n        }\n      }\n      for (var i = 0; i < nodes.length; i += 1) {\n        if (nb.sameEncoding(nodes[i].encoding, newNode.encoding)) {\n          node = nodes[i];\n          break;\n        }\n      }\n      if (node) {\n        if (node.distance > u.distance + newNode.editOp.cost) {\n          node.distance = u.distance + newNode.editOp.cost;\n          node.editOp = newNode.editOp;\n          node.prev = u.prev.concat([u]);\n        }\n      }\n      else {\n        newNode.distance = u.distance + newNode.editOp.cost;\n        newNode.prev = u.prev.concat([u]);\n        nodes.push(newNode);\n      }\n    });\n    doneNodes.push(u);\n  }\n  if (!nb.sameEncoding(u.encoding, d.encoding) && nodes.length === 0) {\n    return [{ name: \"UNREACHABLE\", cost: 999 }];\n  }\n  var result = [].concat(u.prev.map(function (node) {\n    return node.editOp;\n  }).filter(function (editOp) { return editOp; })\n  );\n  result.push(u.editOp);\n  return result ;\n}\n\n\nexports.encodingEditOps = encodingEditOps;\n","'use strict'\nfunction TSP(matrix, value, fixFirst){\n  var head,sequences;\n  function enumSequences(arr){\n    var out = [];\n    if (arr.length === 1) {\n      out.push(arr);\n      return out;\n    }\n    else {\n      for (var i = 0; i < arr.length; i++) {\n        var arrTemp = JSON.parse(JSON.stringify(arr));\n        var head = arrTemp.splice(i,1);\n        enumSequences(arrTemp).map(function(seq){\n          out.push(head.concat(seq));\n        });\n      }\n      return out;\n    }\n  }\n\n  var sequence = matrix[0].map(function(elem, i){\n    return i;\n  });\n\n  if (!isNaN(fixFirst)) {\n    head = sequence.splice(fixFirst,1);\n    sequences = enumSequences(sequence).map(function(elem){\n      return head.concat(elem);\n    });\n\n  }\n  else{\n    sequences = enumSequences(sequence);\n  }\n\n  var minDistance = Infinity;\n  var argMin = 0;\n  var distance = 0;\n  var out = [];\n  var all = [];\n  for (var i = 0; i < sequences.length; i++) {\n    if (i*100/sequences.length %10 === 0) {\n      // process.std.out(i*100/sequences.length);\n    }\n\n\n    for (var j = 0; j < sequences[i].length-1; j++) {\n      distance += matrix[sequences[i][j]][sequences[i][j+1]][value];\n    }\n    distance = Math.round(distance*10000)/10000;\n    all.push({sequence: sequences[i], distance: distance});\n\n    if (distance <= minDistance ) {\n\n      if (distance === minDistance) {\n        out.push({sequence: sequences[i], distance: minDistance});\n      }\n      else{\n        out = [];\n        out.push({sequence: sequences[i], distance: distance});\n      }\n      argMin = i;\n      minDistance = distance;\n      // console.log(i,minDistance);\n    }\n    distance = 0;\n  }\n\n  return {out: out, all: all};\n}\n\n\n// var matrix = JSON.parse(fs.readFileSync(process.argv[2],'utf8'));\n// var fixFirst = Number(process.argv[3]);\n\n// console.log(TSP(matrix,\"rank\",fixFirst));\n\nmodule.exports = {\n  TSP: TSP\n};\n","'use strict'\n//PatternOptimizer\nfunction score(coverage, uniqTransitionSets, appear, patternArray){\n  var R = patternArray.reduce(function(prev, curr){\n    prev += uniqTransitionSets[curr].tr.cost\n    return prev;\n  },0);\n  R = patternArray.length * 4 / R;\n  R = R > 1 ? 1 : R;\n\n  return Math.round(1000000*(1-1/appear.length)*R*coverage)/1000000;\n}\n\nfunction scoreSimple(coverage, patternLength, inputLength){\n  var w_c = 1, w_l = 0;\n\n  return (coverage * w_c + patternLength / inputLength * w_l) / (w_c + w_l);\n}\n\nfunction PatternOptimizer(inputArray, uniqTransitionSets) {\n  var Optimized = [], maxScore = 0;\n  // var inputDistance = distance(inputArray, uniqTransitionSets);\n\n  for (var l = 1; l <= inputArray.length; l++) {\n\n    for (var i = 0; i < inputArray.length-l+1; i++) {\n      var appear = [i];\n      for (var j = 0; j < inputArray.length-l+1; j++) {\n        if ( i !== j && isSameSub(inputArray, i, i + (l-1), j, j + (l-1))) {\n          appear.push(j);\n        }\n      }\n      var overlap = false;\n\n      var rythmic = true;\n      var period = 0;\n      for (var k = 0; k < appear.length-1; k++) {\n        if(appear[k+1] - appear[k] < l){\n          overlap = true;\n          break;\n        }\n        // if(period !== 0 && period !== appear[k+1] - appear[k]){\n        //   rythmic = false;\n        //   break;\n        // }\n        // period = appear[k+1] - appear[k];\n      }\n\n      // if (appear.length > 1 && !overlap && rythmic ){\n      if (appear.length > 1 && !overlap){\n\n        var newPattern = dup(inputArray).splice(i,l);\n        var RPcoverage = coverage(inputArray, l, appear);\n\n        if( !Optimized.find(function(rp){ return s(rp.pattern) === s(newPattern); }) ){\n          newPattern = { 'pattern': newPattern, 'appear': appear, 'coverage': RPcoverage  };\n          newPattern.patternScore = scoreSimple(newPattern.coverage, l, inputArray.length );\n\n          if (newPattern.patternScore > maxScore) {\n            maxScore = newPattern.patternScore;\n            Optimized = [ newPattern ];\n          } else if ( newPattern.patternScore === maxScore ) {\n            Optimized.push(newPattern);\n          }\n\n        }\n      }\n    }\n  }\n\n\n  return Optimized;\n}\nfunction distance(trArray, uniqTransitionSets){\n  return trArray.reduce(function(prev,curr){\n          prev += uniqTransitionSets[curr].tr.cost\n          return prev; },0);\n}\nfunction coverage(array, Patternlength, appear){\n  var s, coverage = 0;\n  for (var i = 0; i < appear.length-1; i++) {\n    s=i;\n    while ( appear[i] + Patternlength > appear[i+1] ) {\n      i++;\n    }\n    coverage += appear[i] + Patternlength - appear[s];\n\n  };\n  if (i===appear.length-1) {\n    coverage += Patternlength;\n  };\n\n  return coverage / array.length;\n}\n\nfunction isSameSub(array, i1, f1, i2, f2) {\n  for (var i = 0; i < (f1-i1+1); i++) {\n    if (array[i1+i] !== array[i2+i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction s(a) {\n  return JSON.stringify(a);\n}\nfunction dup(a) {\n  return JSON.parse(s(a));\n}\n\n// console.log(PatternOptimizer(\"231111\".split(''),[1,1,1,1]));\n// console.log(coverage(\"sdsdxxxasdsdsdaasdsdsdsdsdsdsdsd\".split(''), 2, [ 0, 2, 8, 10, 12, 16, 18, 20, 22, 24, 26, 28, 30 ]))\nmodule.exports = {\n  PatternOptimizer: PatternOptimizer\n};\n","function TieBreaker(result, transitionSetsFromEmptyVis) {\n\tvar TBScore = 0;\n\tvar reasons = {};\n  //rule#1 FILTER_MODIFY, same field, same op, ascending numeric values > descending\n  var continued = { };\n  var filterState = {};\n  var filterScore = [];\n  var filterSequenceCost = 0;\n  for (var i = 0; i < result.charts.length; i++) {\n    let spec = result.charts[i];\n    if (spec.transform ) {\n      let filters = spec.transform.filter(trsfm => trsfm.filter).map(trsfm => trsfm.filter);\n      for (var j = 0; j < filters.length; j++) {\n        let filter = filters[j];\n        if ( filter.hasOwnProperty(\"field\") && filter.hasOwnProperty(\"equal\") ) {\n          if (filterState[filter.field]) {\n            filterState[filter.field].push(filter.equal);\n          } else {\n            filterState[filter.field] = [filter.equal] ;\n            filterScore.push({ \"field\": filter.field, \"score\": 0});\n          }\n        }\n\n      }\n    }\n  }\n\n  for (var i = 0; i < filterScore.length; i++) {\n    for (var j = 1; j < filterState[filterScore[i].field].length; j++) {\n      if ( filterState[filterScore[i].field][j-1] < filterState[filterScore[i].field][j] ) {\n        filterScore[i].score += 1;\n      } else if (filterState[filterScore[i].field][j-1] > filterState[filterScore[i].field][j] ){\n        filterScore[i].score -= 1;\n      }\n    }\n\n    filterSequenceCost += Math.abs(filterScore[i].score + 0.1) / ( filterState[filterScore[i].field].length - 1 + 0.1 );\n  }\n\n  filterSequenceCost = filterScore.length > 0 ? 1 - filterSequenceCost / filterScore.length : 0;\n\n  return { 'tiebreakCost' : filterSequenceCost, 'reasons': filterScore };\n}\n\n\n\nmodule.exports = {\n  TieBreaker: TieBreaker\n};\n","'use strict';\n\nvar trans = require('./../transition/trans.js');\nvar editOp = require('./../editOp/editOpSet.js');\nvar TSP = require('../../lib/TSP.js');\nvar d3 = require('d3');\nvar PO = require('./PatternOptimizer.js');\nvar tb = require('./TieBreaker.js');\n\nasync function sequence(specs, options, editOpSet, callback){\n  if (!editOpSet) {\n    editOpSet = editOp.DEFAULT_EDIT_OPS;\n  }\n\n  function distanceWithPattern(dist, globalWeightingTerm, filterCost){\n    return (dist + filterCost / 1000) * globalWeightingTerm;\n  }\n\n  var transitionSetsFromEmptyVis = await getTransitionSetsFromSpec({ \"mark\":\"null\", \"encoding\": {} }, specs, editOpSet);\n\n    if (!options.fixFirst) {\n    var startingSpec = { \"mark\":\"null\", \"encoding\": {} };\n    specs = [ startingSpec ].concat(specs);\n  }\n\n  var transitions = await getTransitionSets(specs, editOpSet);\n  transitions = extendTransitionSets(transitions);\n\n  var TSPResult = TSP.TSP(transitions, \"cost\", options.fixFirst===true ? 0 : undefined);\n  var TSPResultAll = TSPResult.all.filter(function(seqWithDist){\n    return seqWithDist.sequence[0] === 0;\n  }).map(function(tspR){\n\n    var sequence = tspR.sequence;\n    var transitionSet = [];\n    for (var i = 0; i < sequence.length-1; i++) {\n      transitionSet.push(transitions[sequence[i]][sequence[i+1]]);\n    };\n    var pattern = transitionSet.map(function(r){ return r.id; });\n    var POResult = PO.PatternOptimizer(pattern, transitions.uniq);\n\n    var result = {\n              \"sequence\" : sequence,\n              \"transitions\" : transitionSet,\n              \"sumOfTransitionCosts\" : tspR.distance,\n              \"patterns\" : POResult,\n              \"globalWeightingTerm\" : !!POResult[0] ? 1 - POResult[0].patternScore : 1,\n              \"charts\" : sequence.map(function(index){\n                          return specs[index];\n                        })\n           };\n    var tbResult = tb.TieBreaker(result, transitionSetsFromEmptyVis);\n    result.filterSequenceCost = tbResult.tiebreakCost;\n    result.filterSequenceCostReasons = tbResult.reasons;\n    result.sequenceCost = distanceWithPattern(result.sumOfTransitionCosts, result.globalWeightingTerm, tbResult.tiebreakCost);\n    return result;\n  }).sort(function(a,b){\n    if (a.sequenceCost > b.sequenceCost) {\n      return 1;\n    }\n    if (a.sequenceCost < b.sequenceCost) {\n      return -1;\n    } else {\n      return a.sequence.join(',') > b.sequence.join(',') ? 1 : -1;\n    }\n    return 0;\n  });\n\n  var sequencedSpecs = [];\n  var minSequenceCost = TSPResultAll[0].sequenceCost;\n  for (var i = 0; i < TSPResultAll.length; i++) {\n    if(TSPResultAll[i].sequenceCost === minSequenceCost ){\n      TSPResultAll[i].isOptimum = true;\n    }\n    else {\n      break;\n    }\n  }\n  var returnValue = TSPResultAll;\n\n\n  if(callback){\n    callback(returnValue);\n  }\n  return returnValue;\n}\nasync function getTransitionSetsFromSpec( spec, specs, editOpSet){\n  var transitions = [];\n  for (var i = 0; i < specs.length; i++) {\n    transitions.push(await trans.transition(specs[i], spec, editOpSet, { omitIncludeRawDomin: true }));\n  }\n  return transitions;\n}\n\nasync function getTransitionSets(specs, editOpSet){\n  var transitions = [];\n  for (var i = 0; i < specs.length; i++) {\n    transitions.push([]);\n    for (var j = 0; j < specs.length; j++) {\n      transitions[i].push(await trans.transition(specs[i], specs[j], editOpSet, { omitIncludeRawDomin: true }));\n\n    }\n  }\n  return transitions;\n}\n\nfunction extendTransitionSets(transitions){\n  var uniqTransitionSets = [];\n  var flatCosts = transitions.reduce(function(prev,curr){\n    for (var i = 0; i < curr.length; i++) {\n      prev.push(curr[i].cost);\n      var transitionSetSH = transitionShorthand(curr[i]);\n      var index = uniqTransitionSets.map(function(tr){ return tr.shorthand; }).indexOf(transitionSetSH);\n\n      if ( index === -1) {\n        curr[i][\"id\"] = uniqTransitionSets.push({tr: curr[i], shorthand: transitionSetSH}) - 1;\n      } else {\n        curr[i][\"id\"] = index;\n      }\n\n    };\n    return prev;\n  }, []);\n\n  var uniqueCosts = [...new Set(flatCosts)]\n                      .map(function(val){ return Number(val); })\n                      .sort(function(a,b){ return a-b;});\n\n  var rank = d3.scaleOrdinal()\n    .domain(uniqueCosts)\n    .range([0,uniqueCosts.length]);\n\n  for (var i = 0; i < transitions.length; i++) {\n    for (var j = 0; j < transitions[i].length; j++) {\n      transitions[i][j][\"start\"] = i;\n      transitions[i][j][\"destination\"] = j;\n      transitions[i][j][\"rank\"] = Math.floor(rank(transitions[i][j].cost));\n    }\n  }\n  transitions.uniq = uniqTransitionSets;\n  return transitions\n}\nfunction transitionShorthand(transition){\n  return transition.mark\n                    .concat(transition.transform)\n                    .concat(transition.encoding)\n                    .map(function(tr){\n                      if (tr.detail) {\n                        if (tr.name === \"MODIFY_FILTER\") {\n                          return tr.name + '(' + JSON.stringify(tr.detail.id) + ')';\n                        }\n                        return tr.name + '(' + JSON.stringify(tr.detail) + ')';\n                      }\n                      return tr.name;\n                    })\n                    .sort()\n                    .join('|');\n\n}\nexports.sequence = sequence;\n","const util = require('../util');\nconst vega = require('vega');\nconst vl = require('vega-lite')\nconst {parsePredicateFilter} = require('./trans');\nconst {  OPS, LOGIC_OPS } = require('../constants');\nfunction apply (sSpec, eSpec, editOps) {\n  checkApplyingEditOps(editOps);\n\n  let resultSpec = editOps.reduce((resultSpec, editOp) => {\n    if (editOp.type === \"mark\") {\n      resultSpec = applyMarkEditOp(resultSpec, eSpec, editOp);\n    } else if (editOp.type === \"transform\") {\n      resultSpec = applyTransformEditOp(resultSpec, eSpec, editOp);\n    } else if (editOp.type === \"encoding\") {\n      resultSpec = applyEncodingEditOp(resultSpec, eSpec, editOp);\n    }\n    return resultSpec;\n  }, util.duplicate(sSpec))//an intermediate spec by applying edit operations on the sSpec\n\n  checkSpec(resultSpec);\n  return resultSpec;\n}\nexports.apply = apply\n\nfunction applyMarkEditOp(targetSpec, eSpec, editOp) {\n  let resultSpec = util.duplicate(targetSpec);\n  resultSpec.mark = eSpec.mark\n  return resultSpec;\n}\nexports.applyMarkEditOp = applyMarkEditOp;\n\nfunction applyTransformEditOp(targetSpec, eSpec, editOp){\n  let resultSpec = util.duplicate(targetSpec);\n  const transformType = editOp.name.toLowerCase();\n  const details = !util.isArray(editOp.detail) ? [editOp.detail] : editOp.detail;\n\n  if (transformType.indexOf(\"filter\") >= 0) {\n    if (editOp.name === \"REMOVE_FILTER\" || editOp.name === \"MODIFY_FILTER\") {\n\n      resultSpec.transform.filter(tfm => {\n        return tfm.filter && ((parsePredicateFilter(tfm.filter)[0].id === editOp.detail.id))\n      }).forEach(filter => {\n        if (resultSpec.transform) {\n\n          let i = resultSpec.transform.findIndex(trsfm => util.deepEqual(trsfm, filter))\n\n          resultSpec.transform.splice(i, 1);\n        }\n      })\n    }\n    if (editOp.name === \"ADD_FILTER\" || editOp.name === \"MODIFY_FILTER\") {\n      eSpec.transform.filter(tfm => {\n        return tfm.filter && ((parsePredicateFilter(tfm.filter)[0].id === editOp.detail.id))\n      }).forEach(filter => {\n        if (!resultSpec.transform) {\n          resultSpec.transform = [filter];\n        } else if (!resultSpec.transform.find(trsfm => util.deepEqual(filter, trsfm))) {\n          resultSpec.transform.push(filter);\n        }\n      })\n    }\n  } else {\n    details.forEach(detail => {\n      let fieldDef = resultSpec.encoding[detail.channel];\n      if (fieldDef) {\n        //Todo: cannot apply SCALE if the channel has a different type.\n        if (detail.how === \"removed\"){\n          delete fieldDef[transformType]\n        } else {\n          // console.log(fieldDef.type, detail.fieldType)\n          if (transformType === \"scale\" && fieldDef.type !== detail.fieldType) {\n            throw new UnapplicableEditOPError(`Cannot apply ${editOp.name} since it requires \"${detail.fieldType}\" field instead of \"${fieldDef.type}\".`)\n          }\n          fieldDef[transformType] = eSpec.encoding[detail.channel][transformType]\n        }\n      } else {\n        throw new UnapplicableEditOPError(`Cannot apply ${editOp.name} since there is no \"${detail.channel}\" channel.`)\n      }\n    })\n\n  }\n  return resultSpec;\n}\nexports.applyTransformEditOp = applyTransformEditOp;\n\n\nfunction applyEncodingEditOp(targetSpec, eSpec, editOp){\n  let resultSpec = util.duplicate(targetSpec);\n  if (editOp.name.indexOf(\"REMOVE\") === 0) {\n    let channel = editOp.detail.before.channel;\n    if (resultSpec.encoding[channel]) {\n      delete resultSpec.encoding[channel];\n    } else {\n      throw new UnapplicableEditOPError(`Cannot apply ${editOp.name} since there is no \"${channel}\" channel.`);\n    }\n  } else if (editOp.name.indexOf(\"ADD\") === 0) {\n    let channel = editOp.detail.after.channel;\n    if (resultSpec.encoding[channel]) {\n      throw new UnapplicableEditOPError(`Cannot apply ${editOp.name} since \"${channel}\" already exists.`);\n    } else {\n      resultSpec.encoding[channel] = util.duplicate(eSpec.encoding[channel]);\n    }\n  } else if (editOp.name.indexOf(\"MOVE\") === 0) {\n    let sChannel = editOp.detail.before.channel,\n      dChannel = editOp.detail.after.channel;\n    if (!resultSpec.encoding[sChannel]) {\n      throw new UnapplicableEditOPError(`Cannot apply ${editOp.name} since there is no \"${sChannel}\" channel.`);\n    } else if (resultSpec.encoding[dChannel]) {\n      throw new UnapplicableEditOPError(`Cannot apply ${editOp.name} since \"${dChannel}\" already exists.`);\n    } else {\n      resultSpec.encoding[dChannel] = util.duplicate(resultSpec.encoding[sChannel])\n      delete resultSpec.encoding[sChannel];\n    }\n  } else if (editOp.name.indexOf(\"MODIFY\") === 0) {\n    let channel = editOp.detail.before.channel,\n      field = editOp.detail.after.field,\n      type = editOp.detail.after.type;\n    if (!resultSpec.encoding[channel]) {\n      throw new UnapplicableEditOPError(`Cannot apply ${editOp.name} since there is no \"${channel}\" channel.`);\n    } else {\n      resultSpec.encoding[channel].field = field;\n      resultSpec.encoding[channel].type = type;\n    }\n  } else if (editOp.name.indexOf(\"SWAP_X_Y\") === 0) {\n    if (!resultSpec.encoding.x || !resultSpec.encoding.y) {\n      throw new UnapplicableEditOPError(`Cannot apply ${editOp.name} since there is no \"x\" and \"y\" channels.`);\n    } else {\n      let temp = util.duplicate(resultSpec.encoding.y);\n      resultSpec.encoding.y = util.duplicate(resultSpec.encoding.x);\n      resultSpec.encoding.x = temp;\n    }\n  }\n\n  return resultSpec;\n}\nexports.applyEncodingEditOp = applyEncodingEditOp;\n\nfunction checkSpec(spec) {\n  let lg = vega.logger();\n  const warnings = [], errors = [];\n  lg.warn = (m) => {\n    warnings.push(m);\n  }\n  lg.error = (m) => {\n    errors.push(m);\n  }\n  vl.compile(spec, {logger: lg})\n\n  let hasAggregate = false;\n  for (const key in spec.encoding) {\n    if (spec.encoding.hasOwnProperty(key)) {\n      const fieldDef = spec.encoding[key];\n      if (fieldDef.aggregate) {\n        hasAggregate = true;\n      }\n      if (fieldDef.field === \"*\" && !fieldDef.aggregate) {\n        warnings.push(\"'*' field should innclude aggregate.\")\n      }\n    }\n  }\n  if (hasAggregate) {\n    const hasNoAggOnQField = Object.keys(spec.encoding)\n      .filter(ch => {\n      return spec.encoding[ch].type === \"quantitative\" && !spec.encoding[ch].aggregate\n    }).length > 0\n    if (hasNoAggOnQField) {\n      warnings.push(\"Aggregate should be applied on all quantitative fields.\")\n    }\n  }\n\n\n  if ((warnings.length > 0) || (errors.length > 0)) {\n    throw new InvalidVLSpecError(`The resulted spec is not valid Vega-Lite Spec.`, {warnings, errors})\n  }\n}\nfunction checkApplyingEditOps(editOps) {\n  // _COUNT encodig should be applied with AGGREGATE\n  if (\n    editOps.find(eo => eo.name.indexOf(\"_COUNT\") >= 0) &&\n    !editOps.find(eo => eo.name === \"AGGREGATE\")\n  ) {\n    throw new UnapplicableEditOpsError(\"_COUNT encoding edit operations cannot be applied without AGGREGATE.\");\n  }\n}\nclass UnapplicableEditOPError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"UnapplicableEditOPError\"\n  }\n}\n\nclass InvalidVLSpecError extends Error {\n  constructor(message, info) {\n    super(message);\n    this.name = \"InvalidVLSpecError\"\n    this.info = info;\n  }\n}\nclass UnapplicableEditOpsError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"UnapplicableEditOpsError\"\n  }\n}\n\n","\n// import {default as vl2vg4gemini} from \"../../util/vl2vg4gemini\"\nconst vl = require(\"vega-lite\");\nconst vega = require(\"vega\");\nconst { copy, deepEqual, partition, permutate, union, intersection} = require(\"../util\");\nconst apply = require(\"../transition/apply\").apply;\n\n// Take two vega-lite specs and enumerate paths [{sequence, editOpPartition (aka transition)}]:\nasync function enumerate(sVLSpec, eVLSpec, editOps, transM, withExcluded = false) {\n  if (editOps.length < transM) {\n    throw new CannotEnumStagesMoreThanTransitions(editOps.length, transM)\n  }\n\n  const editOpPartitions = partition(editOps, transM)\n\n  const orderedEditOpPartitions = editOpPartitions.reduce((ordered, pt) => {\n    return ordered.concat(permutate(pt));\n  }, [])\n  const sequences = [];\n\n  let excludedPaths = [];\n\n  for (const editOpPartition of orderedEditOpPartitions) {\n    let sequence = [copy(sVLSpec)];\n    let currSpec = copy(sVLSpec);\n    let valid = true;\n    for (let i = 0; i < editOpPartition.length; i++) {\n      const editOps = editOpPartition[i];\n      if (i===(editOpPartition.length - 1)) {\n        sequence.push(eVLSpec);\n        break; // The last spec should be the same as eVLSpec;\n      }\n\n      try {\n        currSpec = apply(copy(currSpec), eVLSpec, editOps);\n      } catch(e) {\n        if ([\"UnapplicableEditOPError\", \"InvalidVLSpecError\", \"UnapplicableEditOpsError\"].indexOf(e.name) < 0) {\n          throw e;\n        } else {\n          valid = false;\n          excludedPaths.push({info: e, editOpPartition, invalidSpec: currSpec})\n          break;\n        }\n      }\n\n      sequence.push(copy(currSpec));\n    }\n\n    const mergedScaleDomain = await getMergedScale(sequence);\n\n    sequence = sequence.map((currSpec, i) => {\n      if (i===0 || i===sequence.length-1) {\n        return currSpec\n      }\n      return applyMergedScale(currSpec, mergedScaleDomain, editOpPartition[i-1])\n    })\n\n    if (valid && validate(sequence)) {\n      sequences.push({sequence, editOpPartition});\n    }\n  }\n  if (withExcluded) {\n    return {sequences, excludedPaths}\n  }\n\n  return sequences\n}\nexports.enumerate = enumerate;\n\n\nfunction applyMergedScale(vlSpec, mergedScaleDomain, currEditOps) {\n  let currSpec = copy(vlSpec);\n  let sortEditOp = currEditOps.find(eo => eo.name === \"SORT\");\n\n  for (const channel in mergedScaleDomain) {\n    // When sort editOps are applied, do not change the corresponding scale domain.\n    if (sortEditOp && sortEditOp.detail.find(dt => dt.channel === channel)) {\n      continue;\n    };\n\n    if (mergedScaleDomain.hasOwnProperty(channel)) {\n\n      if (currSpec.encoding[channel]) {\n        if (!currSpec.encoding[channel].scale) {\n          currSpec.encoding[channel].scale = {};\n        }\n        currSpec.encoding[channel].scale.domain = mergedScaleDomain[channel];\n        if (currSpec.encoding[channel].scale.zero !== undefined) {\n\n          delete currSpec.encoding[channel].scale.zero\n        }\n      }\n    }\n  }\n  return currSpec\n}\n\n// Get the scales including all data points while doing transitions.\nasync function getMergedScale(sequence) {\n\n  const views = await Promise.all(sequence.map(vlSpec => {\n    return new vega.View(vega.parse(vl.compile(vlSpec).spec), {renderer: \"svg\"}).runAsync()\n  }))\n\n  let commonEncoding = sequence.reduce((commonEncoding, vlSpec, i) => {\n    let encoding = Object.keys(vlSpec.encoding).map(channel => {\n      return {\n        channel,\n        ...vlSpec.encoding[channel],\n        runtimeScale: views[i]._runtime.scales[channel]\n      };\n    });\n    if (i===0){\n      return encoding;\n    }\n    return intersection(encoding, commonEncoding, ch => {\n      return [ch.channel, ch.field||\"\", ch.type||\"\", ch.runtimeScale ? ch.runtimeScale.type : \"\"].join(\"_\");\n    })\n  }, []).map(encoding => {\n    return {\n      ...encoding,\n      domains: views.map(view => {\n        return view._runtime.scales[encoding.channel] ? view._runtime.scales[encoding.channel].value.domain() : undefined\n      })\n    }\n  })\n\n  commonEncoding = commonEncoding.filter(encoding => {\n    //if all the domains are the same, then don't need to merge\n    return !encoding.domains\n      .filter(d => d)\n      .reduce((accDomain, domain) => {\n      if (deepEqual(domain, accDomain)) {\n        return domain;\n      }\n      return undefined;\n    }, encoding.domains[0])\n  })\n\n  return commonEncoding.reduce((mergedScaleDomains, encoding) => {\n    if (!encoding.runtimeScale) {\n      return mergedScaleDomains;\n    }\n    const vlType = encoding.type,\n      domains = encoding.domains;\n\n    if (vlType === \"quantitative\") {\n      mergedScaleDomains[encoding.channel] = [\n        Math.min(...domains.map(domain => domain[0])),\n        Math.max(...domains.map(domain => domain[1]))\n      ]\n    } else if (vlType === \"nominal\" || vlType === \"ordinal\") {\n      mergedScaleDomains[encoding.channel] = domains.reduce((merged, domain) => {\n        return union(merged, domain)\n      }, [])\n    } else if (vlType===\"temporal\") {\n      mergedScaleDomains[encoding.channel] = [\n        Math.min(...domains.map(domain => domain[0])),\n        Math.max(...domains.map(domain => domain[1]))\n      ]\n    }\n\n    return mergedScaleDomains;\n  }, {})\n}\nexports.getMergedScale = getMergedScale\n\n\nfunction validate(sequence) {\n  //Todo: check if the sequence is a valid vega-lite spec.\n  let prevChart = sequence[0];\n  for (let i = 1; i < sequence.length; i++) {\n    const currChart = sequence[i];\n    if (deepEqual(prevChart, currChart)) {\n      return false;\n    }\n    prevChart = sequence[i];\n  }\n  return true;\n}\nexports.validate = validate\n\n\nclass CannotEnumStagesMoreThanTransitions extends Error {\n  constructor(editOpsN, transM) {\n    super(`Cannot enumerate ${transM} transitions for ${editOpsN} edit operations. The number of transitions should lesser than the number of possible edit operations.`)\n    this.name = \"CannotEnumStagesMoreThanTransitions\"\n  }\n}","const { filter } = require(\"d3-array\")\nconst { unique } = require(\"../util\")\n\nexports.HEURISTIC_RULES = [\n  {\n    name: \"filter-then-aggregate\",\n    type: \"A-Then-B\",\n    editOps: [\"FILTER\", \"AGGREGATE\"],\n    condition: (filter, aggregate) => {\n      return aggregate.detail && aggregate.detail.find(dt => dt.how === \"added\")\n    },\n    score: 1\n  },\n  {\n    name: \"disaggregate-then-filter\",\n    type: \"A-Then-B\",\n    editOps: [\"AGGREGATE\", \"FILTER\"],\n    condition: (aggregate, filter) => {\n      return aggregate.detail && aggregate.detail.find(dt => dt.how === \"removed\")\n    },\n    score: 1\n  },\n  {\n    name: \"filter-then-bin\",\n    type: \"A-Then-B\",\n    editOps: [\"FILTER\", \"BIN\"],\n    condition: (filter, bin) => {\n      return bin.detail && bin.detail.find(dt => dt.how === \"added\")\n    },\n    score: 1\n  },\n  {\n    name: \"unbin-then-filter\",\n    type: \"A-Then-B\",\n    editOps: [\"BIN\", \"FILTER\"],\n    condition: (bin, filter) => {\n      return bin.detail && bin.detail.find(dt => dt.how === \"removed\")\n    },\n    score: 1\n  },\n  {\n    name: \"no-aggregate-then-bin\",\n    type: \"A-Then-B\",\n    editOps: [\"AGGREGATE\", \"BIN\"],\n    condition: (aggregate, bin) => {\n      return aggregate.detail && aggregate.detail.find(dt => dt.how === \"added\")\n    },\n    score: -1\n  },\n  {\n    name: \"no-unbin-then-disaggregate\",\n    type: \"A-Then-B\",\n    editOps: [\"BIN\", \"AGGREGATE\"],\n    condition: (bin, aggregate) => {\n      return aggregate.detail && aggregate.detail.find(dt => dt.how === \"removed\")\n    },\n    score: -1\n  },\n\n  {\n    name: \"encoding(MODIFY)-then-aggregate\",\n    type: \"A-Then-B\",\n    editOps: [\"ENCODING\", \"AGGREGATE\"],\n    condition: (encoding, aggregate) => {\n      return encoding.name.indexOf(\"MODIFY\") >= 0\n        && aggregate.detail\n        && aggregate.detail.find(dt => dt.how === \"added\")\n    },\n    score: 1\n  },\n  {\n    name: \"disaggregate-then-encoding(MODIFY)\",\n    type: \"A-Then-B\",\n    editOps: [\"AGGREGATE\", \"ENCODING\"],\n    condition: (aggregate, encoding) => {\n      return encoding.name.indexOf(\"MODIFY\") >= 0\n        && aggregate.detail\n        && aggregate.detail.find(dt => dt.how === \"removed\")\n    },\n    score: 1\n  },\n\n  {\n    name: \"encoding(add)-then-aggregate\",\n    type: \"A-Then-B\",\n    editOps: [\"ENCODING\", \"AGGREGATE\"],\n    condition: (encoding, aggregate) => {\n      return encoding.name.indexOf(\"ADD\") >= 0\n        && aggregate.detail\n        && aggregate.detail.find(dt => dt.how === \"added\")\n    },\n    score: 1\n  },\n  {\n    name: \"disaggregate-then-encoding(remove)\",\n    type: \"A-Then-B\",\n    editOps: [\"AGGREGATE\", \"ENCODING\"],\n    condition: (aggregate, encoding) => {\n      return encoding.name.indexOf(\"REMOVE\") >= 0\n        && aggregate.detail\n        && aggregate.detail.find(dt => dt.how === \"removed\")\n    },\n    score: 1\n  },\n  {\n    name: \"no-mark-then-aggregate\",\n    type: \"A-Then-B\",\n    editOps: [\"MARK\", \"AGGREGATE\" ],\n    condition: (mark, aggregate) => {\n\n      return aggregate.detail && aggregate.detail.find(dt => dt.how === \"added\")\n    },\n    score: -1\n  },\n  {\n    name: \"no-disaggregate-then-mark\",\n    type: \"A-Then-B\",\n    editOps: [\"AGGREGATE\", \"MARK\"],\n    condition: (aggregate, mark ) => {\n\n      return aggregate.detail && aggregate.detail.find(dt => dt.how === \"removed\")\n    },\n    score: -1\n  },\n  {\n    name: \"modifying-with-scale\",\n    type: \"A-With-B\",\n    editOps: [\"ENCODING.MODIFY\", \"SCALE\"],\n    score: 1\n  },\n  {\n    name: \"no-filtering-with-filtering\",\n    type: \"A-With-B\",\n    editOps: [\"FILTER\"],\n    condition: (editOps) => {\n\n      return unique(editOps.FILTER, f => f.position).length < editOps.FILTER.length\n    },\n    score: -1\n  },\n  {\n    name: \"bin-with-aggregate\",\n    type: \"A-With-B\",\n    editOps: [\"AGGREGATE\", \"BIN\"],\n    score: 1\n  },\n  // {\n  //   editOps: [TRANSFORM, ENCODING.REMOVE],\n  //   condition: (transform, remove) => {\n  //     return transform.detail.field === remove.detail.before.field\n  //   },\n  //   score: 1\n  // },\n  // {\n  //   editOps: [TRANSFORM, ENCODING.MODIFY],\n  //   condition: (transform, modify) => {\n  //     return transform.detail.field === modify.detail.after.field\n  //   },\n  //   score: 1\n  // },\n  // {\n  //   editOps: [TRANSFORM, ENCODING.ADD],\n  //   condition: (transform, add) => {\n  //     return transform.detail.field === add.detail.after.field\n  //   },\n  //   score: 1\n  // },\n  // {\n  //   editOps: [ENCODING.MODIFY, TRANSFORM],\n  //   condition: (transform, modify) => {\n  //     return transform.detail.field === modify.detail.before.field\n  //   },\n  //   score: 1\n  // }\n]","const RULES = require(\"./evaluateRules\").HEURISTIC_RULES\nconst {copy, intersection} = require(\"../util\");\n\nfunction evaluate(editOpPartition) {\n  let satisfiedRules = findRules(editOpPartition, RULES);\n  let score = satisfiedRules.reduce((score, rule) => {\n    return score + rule.score\n  }, 0)\n  return {score, satisfiedRules}\n}\nexports.evaluate = evaluate;\n\nfunction findRules(editOpPartition, rules = RULES) {\n  return rules.filter(_rule => {\n    let rule = copy(_rule);\n    for (let j = 0; j < rule.editOps.length; j++) {\n      const ruleEditOp = rule.editOps[j];\n      rule[ruleEditOp] = [];\n\n      for (let i = 0; i < editOpPartition.length; i++) {\n        const editOpPart = editOpPartition[i];\n        let newFoundEditOps = findEditOps(editOpPart, ruleEditOp)\n\n        if (newFoundEditOps.length > 0) {\n          rule[ruleEditOp] = [\n            ...rule[ruleEditOp],\n            ...newFoundEditOps.map(eo => {\n              return {...eo, position: i}\n            })\n          ];\n        }\n      }\n\n      if (rule[ruleEditOp].length === 0) {\n        return false; // when there is no corresponding edit op for the rule in given editOp partition.\n      }\n    }\n\n    if (rule.type === \"A-With-B\"){\n      let foundEditOps = rule.editOps.map(eo => rule[eo]);\n\n      if (foundEditOps.filter(eo => !eo).length !== 0) {\n        return false;\n      }\n      let positions = rule.editOps.reduce((positions, eo, i) => {\n        let currPositions = rule[eo].map(d => d.position);\n        if (i === 0){\n          return currPositions\n        }\n        return intersection(positions, currPositions)\n      }, [])\n\n\n\n      if (positions.length === 0) {\n        return false\n      } else if (_rule.condition) {\n        let mappedFoundEditOps = rule.editOps.reduce((acc, eo) => {\n          acc[eo] = rule[eo]\n          return acc;\n        }, {});\n\n        return _rule.condition(mappedFoundEditOps);\n      }\n      return true;\n\n    } else {\n      for (let i = 0; i < rule[rule.editOps[0]].length; i++) {\n        const followed = rule[rule.editOps[0]][i];\n        for (let j = 0; j < rule[rule.editOps[1]].length; j++) {\n          const following = rule[rule.editOps[1]][j];\n          if (followed.position >= following.position) {\n            return false\n          }\n\n          if (_rule.condition && !_rule.condition(followed, following)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n  });\n}\nexports.findRules = findRules;\n\nfunction findEditOps(editOps, query) {\n  return editOps.filter(eo => {\n    if (query === \"TRANSFORM\") {\n      return eo.type === \"transform\"\n    } else if (query === \"ENCODING\") {\n      return eo.type === \"encoding\"\n    } else if (query === \"MARK\") {\n      return eo.type === \"mark\"\n    } else if (query === \"ENCODING.MODIFY\") {\n      return eo.type === \"encoding\" && eo.name.indexOf(\"MODIFY\") >= 0\n    }\n    return (eo.name.indexOf(query) >= 0)\n  })\n}","const {copy} = require(\"../util\");\nconst { enumerate } = require( \"./enumerate\");\nconst { evaluate } = require( \"./evaluate\");\nconst getTransition = require('../transition/trans.js').transition\nasync function path(sSpec, eSpec, transM=0) {\n  validateInput(sSpec, eSpec);\n\n  const transition = await getTransition(copy(sSpec),  copy(eSpec))\n  const editOps = [\n    ...transition.mark,\n    ...transition.transform,\n    ...transition.encoding\n  ];\n  let result = {}\n  if (transM === 0 ) {\n    for (let m = 1; m <= editOps.length; m++) {\n      result[m] = await enumAndEval(sSpec, eSpec, editOps, m)\n    }\n    return result;\n  }\n\n  return await enumAndEval(sSpec, eSpec, editOps, transM)\n}\nexports.path = path;\n\nasync function enumAndEval(sSpec, eSpec, editOps, transM) {\n  let result = await enumerate(sSpec, eSpec, editOps, transM)\n  return result.map((seq) => {\n    return {\n      ...seq,\n      eval: evaluate(seq.editOpPartition)\n    }\n  }).sort((a,b) => { return b.eval.score - a.eval.score})\n}\n\nfunction validateInput(sSpec, eSpec) {\n  //check if specs are single-view vega-lite chart\n  if (!isValidVLSpec(sSpec) || !isValidVLSpec(eSpec)) {\n    return { error: \"Gemini++ cannot recommend keyframes for the given Vega-Lite charts.\"}\n  }\n}\nexports.validateInput = validateInput;\n\nfunction isValidVLSpec(spec) {\n  if (spec.layer || spec.hconcat || spec.vconcat || spec.concat || spec.spec) {\n    return false;\n  }\n  if (spec.$schema && (spec.$schema.indexOf(\"https://vega.github.io/schema/vega-lite\") >= 0)){\n    return true\n  }\n  return false\n\n}\nexports.isValidVLSpec = isValidVLSpec;","\"use strict\"\nmodule.exports = {\n  sequence: require('./sequence/sequence.js').sequence,\n  transition: require('./transition/trans.js').transition,\n  apply: require('./transition/apply').apply,\n  path: require('./path').path\n}\n"],"names":["accessor","fn","fields","name","fname","getter","path","length","get1","getN","field","obj","len","i","error","message","Error","isFunction","_","opt","p","n","j","c","q","b","s","push","substring","splitAccessPath","get","hop","Object","prototype","hasOwnProperty","has","object","property","call","toSet","RawCode","Literal","Property","Identifier","ArrayExpression","BinaryExpression","CallExpression","ConditionalExpression","LogicalExpression","MemberExpression","ObjectExpression","UnaryExpression","ASTNode","type","TokenName","source","index","lookahead","visit","visitor","this","node","elements","left","right","callee","concat","arguments","test","consequent","alternate","properties","key","value","argument","children","SyntaxIdentifier","MessageUnexpectedToken","MessageInvalidRegExp","MessageUnterminatedRegExp","MessageStrictOctalLiteral","ILLEGAL","DISABLED","RegexNonAsciiIdentifierStart","RegExp","RegexNonAsciiIdentifierPart","assert","condition","isDecimalDigit","ch","isHexDigit","indexOf","isOctalDigit","isWhiteSpace","isLineTerminator","isIdentifierStart","String","fromCharCode","isIdentifierPart","keywords","skipComment","charCodeAt","scanHexEscape","prefix","code","toLowerCase","throwError","scanUnicodeCodePointEscape","cu1","cu2","getEscapedIdentifier","id","substr","scanIdentifier","start","slice","getIdentifier","end","scanPunctuator","code2","ch2","ch3","ch4","ch1","scanNumericLiteral","number","parseInt","scanHexLiteral","octal","scanOctalLiteral","parseFloat","scanRegExp","body","flags","str","classMarker","terminated","literal","scanRegExpBody","search","scanRegExpFlags","pattern","tmp","replace","$0","$1","e","exception","testRegExp","regex","advance","quote","scanStringLiteral","lex","token","peek","pos","finishBinaryExpression","operator","finishCallExpression","args","finishIdentifier","finishLiteral","raw","finishMemberExpression","computed","member","finishProperty","kind","messageFormat","Array","msg","whole","description","throwUnexpected","expect","match","matchKeyword","keyword","parseArrayInitialiser","parseConditionalExpression","finishArrayExpression","parseObjectPropertyKey","parseObjectProperty","parseObjectInitialiser","map","toString","finishObjectExpression","legalKeywords","parsePrimaryExpression","expr","parseExpression","parseGroupExpression","parseArguments","parseNonComputedMember","isIdentifierName","parseNonComputedProperty","parseComputedMember","parsePostfixExpression","parseLeftHandSideExpressionAllowCall","parseUnaryExpression","finishUnaryExpression","binaryPrecedence","prec","marker","markers","stack","pop","parseBinaryExpression","finishConditionalExpression","Constants","NaN","E","LN2","LN10","LOG2E","LOG10E","PI","SQRT1_2","SQRT2","MIN_VALUE","MAX_VALUE","Functions","codegen","cast","lastIndexOf","join","fncall","DATE","STRING","REGEXP","isNaN","isFinite","abs","acos","asin","atan","atan2","ceil","cos","exp","floor","log","max","min","pow","random","round","sin","sqrt","tan","clamp","a","now","utc","datetime","date","day","year","month","hours","minutes","seconds","milliseconds","time","timezoneoffset","utcdate","utcday","utcyear","utcmonth","utchours","utcminutes","utcseconds","utcmilliseconds","indexof","lastindexof","reverse","upper","lower","split","trim","regexp","if","allowed","forbidden","constants","functions","globalvar","fieldvar","outputGlobal","globals","memberDepth","ast","generator","Generators","d","o","stripQuotes","k","result","keys","QUANTITATIVE","ORDINAL","TEMPORAL","NOMINAL","GEOJSON","x","duplicate","undefined","JSON","parse","stringify","nonEmpty","grp","exports","isArray","find","array","f","arrayDiff","filter","findIndex","y","deepEqual","obj1","obj2","isDate","Number","props1","props2","prop","getMonth","item","sp","thisArg","forEach","arr","nestedMap","collection","level","v","r","nestedReduce","reduce","traverse","rest","_i","arr1","arr2","gen","getOpt","create","list","ps","subset","sub","kArray","partition","N_p","newArr","results","pt","newPt","currPt","newP","permutate","acc","anchor","workingArr","splice","maps","curr","sameEncoding","aKeys","util","bKeys","allKeys","union","spec","additionalFields","additionalChannels","importedEncodingEditOps","neighbors","encodingEditOps","def","DEFAULT_ENCODING_EDIT_OPS","inChannels","encoding","exChannels","channel","newNeighbor","editOpType","toUpperCase","editOp","newAdditionalFields","rawEqual","newAdditionalChannels","detail","anotherChannel","tempChannel","exChannel","newNeighborChannels","chIndex","TYPES","CHANNELS","OPS","LOGIC_OPS","require$$0","DEFAULT_EDIT_OPS","require$$1","markEditOps","importedMarkEditOps","newEditOp","editOps","sMarkType","mark","dMarkType","editOpName","sort","console","async","transformEditOps","importedTransformEditOps","transOptions","TRANSFORM_TYPES","transformType","transformSettype","scaleEditOps","transformBasic","found","eo","importedFilterEditOps","filterEditOps","transform","sEditOp","dEditOp","sHas","dHas","how","scaleTransformEditOps","sScaleDef","dScaleDef","sOnlyHasDomainRelated","dOnlyHasDomainRelated","scale","omitIncludeRawDomain","domain","sameDomain","fieldType","from","to","dView","sView","vega","View","vl","compile","renderer","runAsync","sScale","_runtime","scales","dScale","sFilters","dFilters","getFilters","trsfm","dOnly","sOnly","isFind","op","what","before","after","filterExpression","filters","expression","parsePredicateFilter","d3","groups","group","parsed","isString","binaryExprsFromExprTree","parser","bExpr","tree","depth","stringFilter","logicOp","subParsed","nb","u","sChannels","sFields","dChannels","dFields","nearestNode","nodes","minD","Infinity","argMinD","distance","neighbor","cost","prev","doneNodes","ceiling","alternatingCost","newNode","importedTransitionCosts","_transformEditOps","trans","re","moveEditOps","moveEditOp","sChannel","dChannel","removed","dt","added","aggEditOp","binEditOp","TSP","matrix","fixFirst","head","sequences","enumSequences","out","arrTemp","seq","sequence","elem","minDistance","all","Math","scoreSimple","coverage","patternLength","inputLength","Patternlength","appear","isSameSub","i1","f1","i2","f2","PatternOptimizer","inputArray","uniqTransitionSets","Optimized","maxScore","l","overlap","newPattern","RPcoverage","rp","patternScore","TieBreaker","transitionSetsFromEmptyVis","filterState","filterScore","filterSequenceCost","charts","equal","score","transitionShorthand","transition","tr","specs","options","editOpSet","callback","transitions","omitIncludeRawDomin","getTransitionSetsFromSpec","getTransitionSets","flatCosts","transitionSetSH","shorthand","uniqueCosts","Set","val","rank","scaleOrdinal","range","uniq","extendTransitionSets","TSPResultAll","seqWithDist","tspR","transitionSet","dist","globalWeightingTerm","filterCost","POResult","PO","tbResult","tb","tiebreakCost","filterSequenceCostReasons","reasons","sequenceCost","sumOfTransitionCosts","minSequenceCost","isOptimum","returnValue","sSpec","eSpec","UnapplicableEditOpsError","checkApplyingEditOps","resultSpec","applyMarkEditOp","applyTransformEditOp","applyEncodingEditOp","lg","logger","warnings","errors","warn","m","hasAggregate","fieldDef","aggregate","InvalidVLSpecError","checkSpec","targetSpec","details","tfm","UnapplicableEditOPError","temp","constructor","info","copy","intersection","apply","sVLSpec","eVLSpec","transM","withExcluded","CannotEnumStagesMoreThanTransitions","orderedEditOpPartitions","ordered","excludedPaths","editOpPartition","currSpec","valid","invalidSpec","mergedScaleDomain","getMergedScale","applyMergedScale","validate","vlSpec","currEditOps","sortEditOp","zero","views","Promise","commonEncoding","runtimeScale","domains","view","accDomain","mergedScaleDomains","vlType","merged","prevChart","currChart","editOpsN","unique","RULES","bin","FILTER","position","HEURISTIC_RULES","findRules","rules","_rule","rule","ruleEditOp","newFoundEditOps","findEditOps","positions","currPositions","mappedFoundEditOps","followed","following","query","satisfiedRules","enumerate","evaluate","require$$2","getTransition","require$$3","enumAndEval","eval","validateInput","isValidVLSpec","layer","hconcat","vconcat","$schema"],"mappings":"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"}